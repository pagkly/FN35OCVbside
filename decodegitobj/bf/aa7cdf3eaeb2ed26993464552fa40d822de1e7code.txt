b'blob 10493\x00\n/**\n * This service tracks tool activity and disseminates tool activity counts to all registered subscribers.\n * It does this by calling periodically (and asynchronously) down to the server, requesting the latest\n * activity data, and then disseminating it to its subscribers.\n *\n * Subscriber Registration\n * -----------------------\n *\n * To register as a subscriber, call tool_service.register and pass in:\n *\n *   * An id we can use to identify you\n *   * The listener to call when new activity data arrives\n *\n * A typical registration might looks something like this:\n *\n *   top.tool_service.register ( \'toolListener\', listener );\n *\n * (see below for information on how to define a listener object)\n *\n * Subscribers should explicitly unregister when they no longer require our services.\n * Generally, you want to do this when your container is about to disappear, by attaching\n * an unregister call to the _unload_ handler. Something like this:\n *\n *   Event.observe ( window, "unload", function() {\n *     top.tool_service.unregister ( \'toolListener\' );\n *   });\n *\n *\n * Listeners\n * ---------\n *\n * The listener object must implement the following functions:\n *\n *   * activityCountsUpdated: Called when the entire activity store has been refreshed\n *   * activityCountUpdated:  Called when activity for a single tool has been updated. Accept a tool id.\n *\n * These functions don\'t receive any actual activity information -- they\'re expected\n * to call back into the service to get the details they need. An example listener:\n *\n *   var activityListener = {\n *\n *     activityCountsUpdated : function () {\n *\n *       if ( top.tool_service.getActivityCounts() ) {\n *\n *         top.tool_service.getActivityCounts().each ( function ( pair ) {\n *           var toolKey = pair.key;\n *           var toolCount = pair.value;\n *           ...\n *         } );\n *       }\n *\n *     },\n *\n *     activityCountUpdated : function ( toolId ) {\n *\n *       var actitityCount = top.tool_service.getActivityCountForTool(toolId);\n *       ...\n *\n *     }\n *\n *   }\n *\n *.\n * Dependencies\n * ------------\n *\n * This depends on ToolActivityService, a DWR library that handles the call down to the backend\n * server to get activity data.\n *\n * @author  rshehadeh\n * @since   Bb 9.1 SP10\n */\nvar tool_service = {\n\n\n  // ----- public stuff\n\n  MAX_COUNT      : 500,\n  MAX_TOOL_COUNT : 100,\n\n\n  init: function ( refreshInterval, suppressTimestampUpdateHeader )\n  {\n\n    // if the refreshInterval is legit and this timer hasn\'t been set, then set it.\n    if( refreshInterval > 0 && !this.intervalId ) {\n      this.intervalId = setInterval( this.getActivityData.bind( this ), refreshInterval );\n    }\n\n    // the name of the header this service should use to suppress session timestamp updates\n    // when requesting new tool info\n    this.suppressTimestampUpdateHeader = suppressTimestampUpdateHeader;\n\n  },\n\n  /**\n   * Register with the tool service. Registered entities will receive notifications\n   * when new activity counts come in. They must call unregister when their parent\n   * context is unloaded or otherwise goes away (probably using an _onunload_ handler).\n   *\n   * @param  id              The id of the registering entity. Must use the same id when unregistering.\n   * @param  listener        The listener to invoke when new activity comes in\n   */\n  register: function( id, listener ) {\n\n    // register the listener\n    this.registerListener ( id, listener );\n\n    // get new activity data\n    this.getActivityData( );\n\n  },\n\n\n  /**\n   * Unregister the listener with the given id. The id should be the same with which\n   * the listener was registered.\n   *\n   * @param  id  The id of the registering entity. Must use the same id when unregistering.\n   */\n  unregister: function ( id ) {\n    this.unregisterListener ( id );\n  },\n\n\n  /**\n   * Calls down to the server to get the latest activity data for all tools. When\n   * the results comes back, informs all registered listeners.\n   */\n  getActivityData: function ( ) {\n\n    // only phone home if we have listeners registered\n    if ( this.listeners.size() > 0 ) {\n\n      // build the callback object for the tool service call\n      var activityObj = {\n\n        callback: function ( map ) {\n\n          // if the user\'s session is still active, evaluate the results\n          if ( map ) {\n              // if the user is "active", i.e. the session has been updated in the last 15 minutes\n              if(!this.isEmpty(map)) {\n                  this.activityData = $H(map);\n\n                  // inform a listeners that new counts have arrived\n                  this.listeners.each ( function ( pair ) {\n\n                    try {\n                      pair.value.activityCountsUpdated();\n                    }\n\n                    catch (e) {\n\n                      // account for the case that a listener in a context that\'s been unloaded\n                      // is no longer there (eg, a disposed frame/iframe; which is only possible if\n                      // the listener in question failed to unregister). if we run across one of\n                      // these malefactors, unregister it.\n                      if ( e.name === "TypeError" || e.name === "Error" ) {\n                        this.unregisterListener ( pair.key );\n                        // TODO swallow this for now; need better logging mechanism\n                      }\n                    }\n                  }.bind(this));\n              }\n          }\n\n          // the user is not logged in, or his session has timed out, or he\'s a guest; in any\n          // case, no need to keep pinging for activity data\n          else {\n            clearInterval(this.intervalId);\n          }\n\n        }.bind(this),\n\n        errorHandler: function ( errorString, exception ) {\n          // TODO: swallow this for now; need to find a way to report this to users without\n          //       annoying popups\n        },\n\n        headers: {}\n\n      };\n\n      // this header ensures that the call doesn\'t register against the user\'s session\n      // timeout tracker\n      activityObj.headers[this.suppressTimestampUpdateHeader] = "true";\n\n      ToolActivityService.getActivityForAllTools ( activityObj );\n\n    }\n\n  },\n\n\n  /**\n   * Calls down to the server to get the latest activity count for a given tool. When\n   * the results comes back, informs all registered listeners.\n   *\n   * @param toolId The fully-qualified id of the tool to\n   * @param userId The id to the user to get activity data for\n   */\n  /*jslint funcscope: true */\n  getActivityDataForTool: function ( toolId ) {\n\n    // only phone home if we have listeners registered\n    if ( this.listeners.size() > 0 ) {\n\n      // build the callback object for the call to get tool activity\n      var activityObj = {\n\n        callback: function ( activityCount ) {\n\n          if ( activityCount >= 0 ) {\n\n            this.activityData.set ( toolId, activityCount );\n\n            this.listeners.each ( function ( pair) {\n              try {\n                pair.value.activityCountUpdated( toolId );\n              }\n\n              catch (e) {\n\n                // account for the case that a listener in a context that\'s been unloaded\n                // is no longer there (eg, a disposed frame/iframe; which is only possible if\n                // the listener in question failed to unregister). if we run across one of\n                // these malefactors, unregister it.\n                if ( e.name === "TypeError" || e.name === "Error" ) {\n                  this.unregisterListener ( pair.key );\n                  // TODO swallow this for now; need better logging mechanism\n                }\n\n              }\n\n            });\n\n          }\n\n          // the user is not logged in, or his session has timed out, or he\'s a guest; in any\n          // case, no need to keep pinging for activity data\n          else {\n            clearInterval(this.intervalId);\n          }\n\n\n        }.bind(this),\n\n        errorHandler: function ( errorString, exception ) {\n           // TODO: swallow this for now; need to find a way to report this to users without\n           //       annoying popups\n        },\n\n        headers: {}\n\n       };\n\n      }\n\n     // this header ensures that the call doesn\'t register against the user\'s session\n     // timeout tracker\n      activityObj.headers[this.suppressTimestampUpdateHeader] = "true";\n\n      ToolActivityService.getActivityForTool ( toolId, activityObj );\n\n  },\n\n\n  /**\n   * Get the total activity account, across all tools.\n   */\n  getTotalActivityCount : function ( ) {\n\n    var total = 0;\n\n    this.activityData.values().collect ( function ( count, total ) {\n      total += count;\n    } );\n\n    return total;\n\n  },\n\n\n  /**\n   * Returns activity counts for the tool corresponding to the given id. If no counts\n   * are available (or the tool doesn\'t exist) returns null.\n   *\n   * @param toolId  The id of the tool\n   * @return        The count, or null\n   */\n  getActivityCountForTool: function ( toolId ) {\n    return this.activityData.get(toolId) ? this.activityData.get(toolId) : null;\n  },\n\n\n  /**\n   * Returns a hash of all extant tool activity counts, in the form;\n   *\n   *   [tool id] => [count]\n   */\n  getActivityCounts: function () {\n    return this.activityData;\n  },\n\n  /**\n   * check if a map is empty or not\n   *  \n   */\n  isEmpty: function (map) {\n      for(var key in map) {\n          if (map.hasOwnProperty(key)) {\n              return false;\n          }\n      }\n      return true;\n  },\n\t\n  /**\n   * Formats an activity count for display. If the count is larger than the\n   * given max, abbreviates it to that max, with an indication that there\'s\n   * more.\n   *\n   * @param count The count to format\n   * @param max   The max value to display\n   */\n  formatCount:  function ( count, max ) {\n    return count > max ? max + "+" : count;\n  },\n\n\n  // ----- private stuff\n\n  intervalId: null,\n\n  // activity data\n  activityData : $H(),\n\n  // activity listeners\n  listeners: $H(),\n\n\n  /**\n   * Register a listener, and tie it to the given id. Existing listeners with the\n   * same id will be ovewritten.\n   *\n   * @param id        The id of listener\n   * @param listener  The listener.\n   */\n  registerListener: function ( id, listener ) {\n    this.listeners.set ( id, listener );\n  },\n\n\n  /**\n   * Unregister a single listener, with the given id.\n   *\n   * @param id  The id of listener\n   */\n  unregisterListener: function ( id ) {\n    this.listeners.unset ( id );\n  }\n\n};\n'