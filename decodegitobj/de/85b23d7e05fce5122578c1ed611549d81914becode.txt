b'blob 47251\x00/*\n * Copyright 2005 Joe Walker\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Declare an object to which we can add real functions.\n */\nif (dwr == null) var dwr = {};\nif (dwr.engine == null) dwr.engine = {};\nif (DWREngine == null) var DWREngine = dwr.engine;\n\n/**\n * Set an alternative error handler from the default alert box.\n * @see getahead.org/dwr/browser/engine/errors\n */\ndwr.engine.setErrorHandler = function(handler) {\n  dwr.engine._errorHandler = handler;\n};\n\n/**\n * Set an alternative warning handler from the default alert box.\n * @see getahead.org/dwr/browser/engine/errors\n */\ndwr.engine.setWarningHandler = function(handler) {\n  dwr.engine._warningHandler = handler;\n};\n\n/**\n * Setter for the text/html handler - what happens if a DWR request gets an HTML\n * reply rather than the expected Javascript. Often due to login timeout\n */\ndwr.engine.setTextHtmlHandler = function(handler) {\n  dwr.engine._textHtmlHandler = handler;\n};\n\n/**\n * Set a default timeout value for all calls. 0 (the default) turns timeouts off.\n * @see getahead.org/dwr/browser/engine/errors\n */\ndwr.engine.setTimeout = function(timeout) {\n  dwr.engine._timeout = timeout;\n};\n\n/**\n * The Pre-Hook is called before any DWR remoting is done.\n * @see getahead.org/dwr/browser/engine/hooks\n */\ndwr.engine.setPreHook = function(handler) {\n  dwr.engine._preHook = handler;\n};\n\n/**\n * The Post-Hook is called after any DWR remoting is done.\n * @see getahead.org/dwr/browser/engine/hooks\n */\ndwr.engine.setPostHook = function(handler) {\n  dwr.engine._postHook = handler;\n};\n\n/**\n * Custom headers for all DWR calls\n * @see getahead.org/dwr/????\n */\ndwr.engine.setHeaders = function(headers) {\n  dwr.engine._headers = headers;\n};\n\n/**\n * Custom parameters for all DWR calls\n * @see getahead.org/dwr/????\n */\ndwr.engine.setParameters = function(parameters) {\n  dwr.engine._parameters = parameters;\n};\n\n/** XHR remoting type constant. See dwr.engine.set[Rpc|Poll]Type() */\ndwr.engine.XMLHttpRequest = 1;\n\n/** XHR remoting type constant. See dwr.engine.set[Rpc|Poll]Type() */\ndwr.engine.IFrame = 2;\n\n/** XHR remoting type constant. See dwr.engine.setRpcType() */\ndwr.engine.ScriptTag = 3;\n\n/**\n * Set the preferred remoting type.\n * @param newType One of dwr.engine.XMLHttpRequest or dwr.engine.IFrame or dwr.engine.ScriptTag\n * @see getahead.org/dwr/browser/engine/options\n */\ndwr.engine.setRpcType = function(newType) {\n  if (newType != dwr.engine.XMLHttpRequest && newType != dwr.engine.IFrame && newType != dwr.engine.ScriptTag) {\n    dwr.engine._handleError(null, { name:"dwr.engine.invalidRpcType", message:"RpcType must be one of dwr.engine.XMLHttpRequest or dwr.engine.IFrame or dwr.engine.ScriptTag" });\n    return;\n  }\n  dwr.engine._rpcType = newType;\n};\n\n/**\n * Which HTTP method do we use to send results? Must be one of "GET" or "POST".\n * @see getahead.org/dwr/browser/engine/options\n */\ndwr.engine.setHttpMethod = function(httpMethod) {\n  if (httpMethod != "GET" && httpMethod != "POST") {\n    dwr.engine._handleError(null, { name:"dwr.engine.invalidHttpMethod", message:"Remoting method must be one of GET or POST" });\n    return;\n  }\n  dwr.engine._httpMethod = httpMethod;\n};\n\n/**\n * Ensure that remote calls happen in the order in which they were sent? (Default: false)\n * @see getahead.org/dwr/browser/engine/ordering\n */\ndwr.engine.setOrdered = function(ordered) {\n  dwr.engine._ordered = ordered;\n};\n\n/**\n * Do we ask the XHR object to be asynchronous? (Default: true)\n * @see getahead.org/dwr/browser/engine/options\n */\ndwr.engine.setAsync = function(async) {\n  dwr.engine._async = async;\n};\n\n/**\n * Does DWR poll the server for updates? (Default: false)\n * @see getahead.org/dwr/browser/engine/options\n */\ndwr.engine.setActiveReverseAjax = function(activeReverseAjax) {\n  if (activeReverseAjax) {\n    // Bail if we are already started\n    if (dwr.engine._activeReverseAjax) return;\n    dwr.engine._activeReverseAjax = true;\n    dwr.engine._poll();\n  }\n  else {\n    // Can we cancel an existing request?\n    if (dwr.engine._activeReverseAjax && dwr.engine._pollReq) dwr.engine._pollReq.abort();\n    dwr.engine._activeReverseAjax = false;\n  }\n  // TODO: in iframe mode, if we start, stop, start then the second start may\n  // well kick off a second iframe while the first is still about to return\n  // we should cope with this but we don\'t\n};\n\n/**\n * The default message handler.\n * @see getahead.org/dwr/browser/engine/errors\n */\ndwr.engine.defaultErrorHandler = function(message, ex) {\n  dwr.engine._debug("Error: " + ex.name + ", " + ex.message, true);\n  if (message == null || message == "") alert("A server error has occured.");\n  // Ignore NS_ERROR_NOT_AVAILABLE if Mozilla is being narky\n  else if (message.indexOf("0x80040111") != -1) dwr.engine._debug(message);\n  else alert(message);\n};\n\n/**\n * The default warning handler.\n * @see getahead.org/dwr/browser/engine/errors\n */\ndwr.engine.defaultWarningHandler = function(message, ex) {\n  dwr.engine._debug(message);\n};\n\n/**\n * For reduced latency you can group several remote calls together using a batch.\n * @see getahead.org/dwr/browser/engine/batch\n */\ndwr.engine.beginBatch = function() {\n  if (dwr.engine._batch) {\n    dwr.engine._handleError(null, { name:"dwr.engine.batchBegun", message:"Batch already begun" });\n    return;\n  }\n  dwr.engine._batch = dwr.engine._createBatch();\n};\n\n/**\n * Finished grouping a set of remote calls together. Go and execute them all.\n * @see getahead.org/dwr/browser/engine/batch\n */\ndwr.engine.endBatch = function(options) {\n  var batch = dwr.engine._batch;\n  if (batch == null) {\n    dwr.engine._handleError(null, { name:"dwr.engine.batchNotBegun", message:"No batch in progress" });\n    return;\n  }\n  dwr.engine._batch = null;\n  if (batch.map.callCount == 0) return;\n\n  // The hooks need to be merged carefully to preserve ordering\n  if (options) dwr.engine._mergeBatch(batch, options);\n\n  // In ordered mode, we don\'t send unless the list of sent items is empty\n  if (dwr.engine._ordered && dwr.engine._batchesLength != 0) {\n    dwr.engine._batchQueue[dwr.engine._batchQueue.length] = batch;\n  }\n  else {\n    dwr.engine._sendData(batch);\n  }\n};\n\n/** @deprecated */\ndwr.engine.setPollMethod = function(type) { dwr.engine.setPollType(type); };\ndwr.engine.setMethod = function(type) { dwr.engine.setRpcType(type); };\ndwr.engine.setVerb = function(verb) { dwr.engine.setHttpMethod(verb); };\ndwr.engine.setPollType = function() { dwr.engine._debug("Manually setting the Poll Type is not supported"); };\n\n//==============================================================================\n// Only private stuff below here\n//==============================================================================\n\n/** The original page id sent from the server */\ndwr.engine._origScriptSessionId = "8A22AEE4C7B3F9CA3A094735175A6B14";\n\n/** The session cookie name */\ndwr.engine._sessionCookieName = "JSESSIONID"; // JSESSIONID\n\n/** Is GET enabled for the benefit of Safari? */\ndwr.engine._allowGetForSafariButMakeForgeryEasier = "false";\n\n/** The script prefix to strip in the case of scriptTagProtection. */\ndwr.engine._scriptTagProtection = "throw \'allowScriptTagRemoting is false.\';";\n\n/** The default path to the DWR servlet */\ndwr.engine._defaultPath = "/webapps/blackboard/dwr";\n\n/** Do we use XHR for reverse ajax because we are not streaming? */\ndwr.engine._pollWithXhr = "false";\n\n/** The read page id that we calculate */\ndwr.engine._scriptSessionId = null;\n\n/** The function that we use to fetch/calculate a session id */\ndwr.engine._getScriptSessionId = function() {\n  if (dwr.engine._scriptSessionId == null) {\n    dwr.engine._scriptSessionId = dwr.engine._origScriptSessionId + Math.floor(Math.random() * 1000);\n  }\n  return dwr.engine._scriptSessionId;\n};\n\n/** A function to call if something fails. */\ndwr.engine._errorHandler = dwr.engine.defaultErrorHandler;\n\n/** For debugging when something unexplained happens. */\ndwr.engine._warningHandler = dwr.engine.defaultWarningHandler;\n\n/** A function to be called before requests are marshalled. Can be null. */\ndwr.engine._preHook = null;\n\n/** A function to be called after replies are received. Can be null. */\ndwr.engine._postHook = null;\n\n/** An map of the batches that we have sent and are awaiting a reply on. */\ndwr.engine._batches = {};\n\n/** A count of the number of outstanding batches. Should be == to _batches.length unless prototype has messed things up */\ndwr.engine._batchesLength = 0;\n\n/** In ordered mode, the array of batches waiting to be sent */\ndwr.engine._batchQueue = [];\n\n/** What is the default rpc type */\ndwr.engine._rpcType = dwr.engine.XMLHttpRequest;\n\n/** What is the default remoting method (ie GET or POST) */\ndwr.engine._httpMethod = "POST";\n\n/** Do we attempt to ensure that calls happen in the order in which they were sent? */\ndwr.engine._ordered = false;\n\n/** Do we make the calls async? */\ndwr.engine._async = true;\n\n/** The current batch (if we are in batch mode) */\ndwr.engine._batch = null;\n\n/** The global timeout */\ndwr.engine._timeout = 0;\n\n/** ActiveX objects to use when we want to convert an xml string into a DOM object. */\ndwr.engine._DOMDocument = ["Msxml2.DOMDocument.6.0", "Msxml2.DOMDocument.5.0", "Msxml2.DOMDocument.4.0", "Msxml2.DOMDocument.3.0", "MSXML2.DOMDocument", "MSXML.DOMDocument", "Microsoft.XMLDOM"];\n\n/** The ActiveX objects to use when we want to do an XMLHttpRequest call. */\ndwr.engine._XMLHTTP = ["Msxml2.XMLHTTP.6.0", "Msxml2.XMLHTTP.5.0", "Msxml2.XMLHTTP.4.0", "MSXML2.XMLHTTP.3.0", "MSXML2.XMLHTTP", "Microsoft.XMLHTTP"];\n\n/** Are we doing comet or polling? */\ndwr.engine._activeReverseAjax = false;\n\n/** The iframe that we are using to poll */\ndwr.engine._outstandingIFrames = [];\n\n/** The xhr object that we are using to poll */\ndwr.engine._pollReq = null;\n\n/** How many milliseconds between internal comet polls */\ndwr.engine._pollCometInterval = 200;\n\n/** How many times have we re-tried to poll? */\ndwr.engine._pollRetries = 0;\ndwr.engine._maxPollRetries = 0;\n\n/** Do we do a document.reload if we get a text/html reply? */\ndwr.engine._textHtmlHandler = null;\n\n/** If you wish to send custom headers with every request */\ndwr.engine._headers = null;\n\n/** If you wish to send extra custom request parameters with each request */\ndwr.engine._parameters = null;\n\n/** Undocumented interceptors - do not use */\ndwr.engine._postSeperator = "\\n";\ndwr.engine._defaultInterceptor = function(data) { return data; };\ndwr.engine._urlRewriteHandler = dwr.engine._defaultInterceptor;\ndwr.engine._contentRewriteHandler = dwr.engine._defaultInterceptor;\ndwr.engine._replyRewriteHandler = dwr.engine._defaultInterceptor;\n\n/** Batch ids allow us to know which batch the server is answering */\ndwr.engine._nextBatchId = 0;\n\n/** A list of the properties that need merging from calls to a batch */\ndwr.engine._propnames = [ "rpcType", "httpMethod", "async", "timeout", "errorHandler", "warningHandler", "textHtmlHandler" ];\n\n/** Do we stream, or can be hacked to do so? */\ndwr.engine._partialResponseNo = 0;\ndwr.engine._partialResponseYes = 1;\ndwr.engine._partialResponseFlush = 2;\n\n/** Is this page in the process of unloading? */\ndwr.engine._unloading = false;\n\n/**\n * @private Send a request. Called by the Javascript interface stub\n * @param path part of URL after the host and before the exec bit without leading or trailing /s\n * @param scriptName The class to execute\n * @param methodName The method on said class to execute\n * @param func The callback function to which any returned data should be passed\n *       if this is null, any returned data will be ignored\n * @param vararg_params The parameters to pass to the above class\n */\ndwr.engine._execute = function(path, scriptName, methodName, vararg_params) {\n  var singleShot = false;\n  if (dwr.engine._batch == null) {\n    dwr.engine.beginBatch();\n    singleShot = true;\n  }\n  var batch = dwr.engine._batch;\n  // To make them easy to manipulate we copy the arguments into an args array\n  var args = [];\n  for (var i = 0; i < arguments.length - 3; i++) {\n    args[i] = arguments[i + 3];\n  }\n  // All the paths MUST be to the same servlet\n  if (batch.path == null) {\n    batch.path = path;\n  }\n  else {\n    if (batch.path != path) {\n      dwr.engine._handleError(batch, { name:"dwr.engine.multipleServlets", message:"Can\'t batch requests to multiple DWR Servlets." });\n      return;\n    }\n  }\n  // From the other params, work out which is the function (or object with\n  // call meta-data) and which is the call parameters\n  var callData;\n  var lastArg = args[args.length - 1];\n  if (typeof lastArg == "function" || lastArg == null) callData = { callback:args.pop() };\n  else callData = args.pop();\n\n  // Merge from the callData into the batch\n  dwr.engine._mergeBatch(batch, callData);\n  batch.handlers[batch.map.callCount] = {\n    exceptionHandler:callData.exceptionHandler,\n    callback:callData.callback\n  };\n\n  // Copy to the map the things that need serializing\n  var prefix = "c" + batch.map.callCount + "-";\n  batch.map[prefix + "scriptName"] = scriptName;\n  batch.map[prefix + "methodName"] = methodName;\n  batch.map[prefix + "id"] = batch.map.callCount;\n  for (i = 0; i < args.length; i++) {\n    dwr.engine._serializeAll(batch, [], args[i], prefix + "param" + i);\n  }\n\n  // Now we have finished remembering the call, we incr the call count\n  batch.map.callCount++;\n  if (singleShot) dwr.engine.endBatch();\n};\n\n/** @private Poll the server to see if there is any data waiting */\ndwr.engine._poll = function() {\n  if (!dwr.engine._activeReverseAjax) return;\n\n  var batch = dwr.engine._createBatch();\n  batch.map.id = 0; // TODO: Do we need this??\n  batch.map.callCount = 1;\n  batch.isPoll = true;\n  if (dwr.engine._pollWithXhr == "true") {\n    batch.rpcType = dwr.engine.XMLHttpRequest;\n    batch.map.partialResponse = dwr.engine._partialResponseNo;\n  }\n  else {\n    if (navigator.userAgent.indexOf("Gecko/") != -1) {\n      batch.rpcType = dwr.engine.XMLHttpRequest;\n      batch.map.partialResponse = dwr.engine._partialResponseYes;\n    }\n    else {\n      batch.rpcType = dwr.engine.XMLHttpRequest;\n      batch.map.partialResponse = dwr.engine._partialResponseNo;\n    }\n  }\n  batch.httpMethod = "POST";\n  batch.async = true;\n  batch.timeout = 0;\n  batch.path = dwr.engine._defaultPath;\n  batch.preHooks = [];\n  batch.postHooks = [];\n  batch.errorHandler = dwr.engine._pollErrorHandler;\n  batch.warningHandler = dwr.engine._pollErrorHandler;\n  batch.handlers[0] = {\n    callback:function(pause) {\n      dwr.engine._pollRetries = 0;\n      setTimeout(dwr.engine._poll, pause);\n    }\n  };\n\n  // Send the data\n  dwr.engine._sendData(batch);\n  if (batch.rpcType == dwr.engine.XMLHttpRequest && batch.map.partialResponse == dwr.engine._partialResponseYes) {\n    dwr.engine._checkCometPoll();\n  }\n};\n\n/** Try to recover from polling errors */\ndwr.engine._pollErrorHandler = function(msg, ex) {\n  // if anything goes wrong then just silently try again (up to 3x) after 10s\n  dwr.engine._pollRetries++;\n  dwr.engine._debug("Reverse Ajax poll failed (pollRetries=" + dwr.engine._pollRetries + "): " + ex.name + " : " + ex.message);\n  if (dwr.engine._pollRetries < dwr.engine._maxPollRetries) {\n    setTimeout(dwr.engine._poll, 10000);\n  }\n  else {\n    dwr.engine._activeReverseAjax = false;\n    dwr.engine._debug("Giving up.");\n  }\n};\n\n/** @private Generate a new standard batch */\ndwr.engine._createBatch = function() {\n  var batch = {\n    map:{\n      callCount:0,\n      page:window.location.pathname + window.location.search,\n      httpSessionId:dwr.engine._getJSessionId(),\n      scriptSessionId:dwr.engine._getScriptSessionId()\n    },\n    charsProcessed:0, paramCount:0,\n    parameters:{}, headers:{},\n    isPoll:false, handlers:{}, preHooks:[], postHooks:[],\n    rpcType:dwr.engine._rpcType,\n    httpMethod:dwr.engine._httpMethod,\n    async:dwr.engine._async,\n    timeout:dwr.engine._timeout,\n    errorHandler:dwr.engine._errorHandler,\n    warningHandler:dwr.engine._warningHandler,\n    textHtmlHandler:dwr.engine._textHtmlHandler\n  };\n  if (dwr.engine._preHook) batch.preHooks.push(dwr.engine._preHook);\n  if (dwr.engine._postHook) batch.postHooks.push(dwr.engine._postHook);\n  var propname, data;\n  if (dwr.engine._headers) {\n    for (propname in dwr.engine._headers) {\n      data = dwr.engine._headers[propname];\n      if (typeof data != "function") batch.headers[propname] = data;\n    }\n  }\n  if (dwr.engine._parameters) {\n    for (propname in dwr.engine._parameters) {\n      data = dwr.engine._parameters[propname];\n      if (typeof data != "function") batch.parameters[propname] = data;\n    }\n  }\n  return batch;\n};\n\n/** @private Take further options and merge them into */\ndwr.engine._mergeBatch = function(batch, overrides) {\n  var propname, data;\n  for (var i = 0; i < dwr.engine._propnames.length; i++) {\n    propname = dwr.engine._propnames[i];\n    if (overrides[propname] != null) batch[propname] = overrides[propname];\n  }\n  if (overrides.preHook != null) batch.preHooks.unshift(overrides.preHook);\n  if (overrides.postHook != null) batch.postHooks.push(overrides.postHook);\n  if (overrides.headers) {\n    for (propname in overrides.headers) {\n      data = overrides.headers[propname];\n      if (typeof data != "function") batch.headers[propname] = data;\n    }\n  }\n  if (overrides.parameters) {\n    for (propname in overrides.parameters) {\n      data = overrides.parameters[propname];\n      if (typeof data != "function") batch.map["p-" + propname] = "" + data;\n    }\n  }\n};\n\n/** @private What is our session id? */\ndwr.engine._getJSessionId =  function() {\n  var cookies = document.cookie.split(\';\');\n  for (var i = 0; i < cookies.length; i++) {\n    var cookie = cookies[i];\n    while (cookie.charAt(0) == \' \') cookie = cookie.substring(1, cookie.length);\n    if (cookie.indexOf(dwr.engine._sessionCookieName + "=") == 0) {\n      return cookie.substring(dwr.engine._sessionCookieName.length + 1, cookie.length);\n    }\n  }\n  return "";\n};\n\n/** @private Check for reverse Ajax activity */\ndwr.engine._checkCometPoll = function() {\n  for (var i = 0; i < dwr.engine._outstandingIFrames.length; i++) {\n    var text = "";\n    var iframe = dwr.engine._outstandingIFrames[i];\n    try {\n      text = dwr.engine._getTextFromCometIFrame(iframe);\n    }\n    catch (ex) {\n      dwr.engine._handleWarning(iframe.batch, ex);\n    }\n    if (text != "") dwr.engine._processCometResponse(text, iframe.batch);\n  }\n  if (dwr.engine._pollReq) {\n    var req = dwr.engine._pollReq;\n    var text = req.responseText;\n    if (text != null) dwr.engine._processCometResponse(text, req.batch);\n  }\n\n  // If the poll resources are still there, come back again\n  if (dwr.engine._outstandingIFrames.length > 0 || dwr.engine._pollReq) {\n    setTimeout(dwr.engine._checkCometPoll, dwr.engine._pollCometInterval);\n  }\n};\n\n/** @private Extract the whole (executed an all) text from the current iframe */\ndwr.engine._getTextFromCometIFrame = function(frameEle) {\n  var body = frameEle.contentWindow.document.body;\n  if (body == null) return "";\n  var text = body.innerHTML;\n  // We need to prevent IE from stripping line feeds\n  if (text.indexOf("<PRE>") == 0 || text.indexOf("<pre>") == 0) {\n    text = text.substring(5, text.length - 7);\n  }\n  return text;\n};\n\n/** @private Some more text might have come in, test and execute the new stuff */\ndwr.engine._processCometResponse = function(response, batch) {\n  if (batch.charsProcessed == response.length) return;\n  if (response.length == 0) {\n    batch.charsProcessed = 0;\n    return;\n  }\n\n  var firstStartTag = response.indexOf("//#DWR-START#", batch.charsProcessed);\n  if (firstStartTag == -1) {\n    // dwr.engine._debug("No start tag (search from " + batch.charsProcessed + "). skipping \'" + response.substring(batch.charsProcessed) + "\'");\n    batch.charsProcessed = response.length;\n    return;\n  }\n  // if (firstStartTag > 0) {\n  //   dwr.engine._debug("Start tag not at start (search from " + batch.charsProcessed + "). skipping \'" + response.substring(batch.charsProcessed, firstStartTag) + "\'");\n  // }\n\n  var lastEndTag = response.lastIndexOf("//#DWR-END#");\n  if (lastEndTag == -1) {\n    // dwr.engine._debug("No end tag. unchanged charsProcessed=" + batch.charsProcessed);\n    return;\n  }\n\n  // Skip the end tag too for next time, remembering CR and LF\n  if (response.charCodeAt(lastEndTag + 11) == 13 && response.charCodeAt(lastEndTag + 12) == 10) {\n    batch.charsProcessed = lastEndTag + 13;\n  }\n  else {\n    batch.charsProcessed = lastEndTag + 11;\n  }\n\n  var exec = response.substring(firstStartTag + 13, lastEndTag);\n\n  dwr.engine._receivedBatch = batch;\n  dwr.engine._eval(exec);\n  dwr.engine._receivedBatch = null;\n};\n\n/** @private Actually send the block of data in the batch object. */\ndwr.engine._sendData = function(batch) {\n  batch.map.batchId = dwr.engine._nextBatchId;\n  dwr.engine._nextBatchId++;\n  dwr.engine._batches[batch.map.batchId] = batch;\n  dwr.engine._batchesLength++;\n  batch.completed = false;\n\n  for (var i = 0; i < batch.preHooks.length; i++) {\n    batch.preHooks[i]();\n  }\n  batch.preHooks = null;\n  // Set a timeout\n  if (batch.timeout && batch.timeout != 0) {\n    batch.timeoutId = setTimeout(function() { dwr.engine._abortRequest(batch); }, batch.timeout);\n  }\n  // Get setup for XMLHttpRequest if possible\n  if (batch.rpcType == dwr.engine.XMLHttpRequest) {\n    if (window.XMLHttpRequest) {\n      batch.req = new XMLHttpRequest();\n    }\n    // IE5 for the mac claims to support window.ActiveXObject, but throws an error when it\'s used\n    else if (window.ActiveXObject && !(navigator.userAgent.indexOf("Mac") >= 0 && navigator.userAgent.indexOf("MSIE") >= 0)) {\n      batch.req = dwr.engine._newActiveXObject(dwr.engine._XMLHTTP);\n    }\n  }\n\n  var prop, request;\n  if (batch.req) {\n    // Proceed using XMLHttpRequest\n    if (batch.async) {\n      batch.req.onreadystatechange = function() {\n        if (typeof dwr != \'undefined\') dwr.engine._stateChange(batch);\n      };\n    }\n    // If we\'re polling, record this for monitoring\n    if (batch.isPoll) {\n      dwr.engine._pollReq = batch.req;\n      // In IE XHR is an ActiveX control so you can\'t augment it like this\n      if (!(document.all && !window.opera)) batch.req.batch = batch;\n    }\n    // Workaround for Safari 1.x POST bug\n    var indexSafari = navigator.userAgent.indexOf("Safari/");\n    if (indexSafari >= 0) {\n      var version = navigator.userAgent.substring(indexSafari + 7);\n      if (parseInt(version, 10) < 400) {\n        if (dwr.engine._allowGetForSafariButMakeForgeryEasier == "true") batch.httpMethod = "GET";\n        else dwr.engine._handleWarning(batch, { name:"dwr.engine.oldSafari", message:"Safari GET support disabled. See getahead.org/dwr/server/servlet and allowGetForSafariButMakeForgeryEasier." });\n      }\n    }\n    batch.mode = batch.isPoll ? dwr.engine._ModePlainPoll : dwr.engine._ModePlainCall;\n    request = dwr.engine._constructRequest(batch);\n    try {\n      batch.req.open(batch.httpMethod, request.url, batch.async);\n      try {\n        for (prop in batch.headers) {\n          var value = batch.headers[prop];\n          if (typeof value == "string") batch.req.setRequestHeader(prop, value);\n        }\n        if (!batch.headers["Content-Type"]) batch.req.setRequestHeader("Content-Type", "text/plain");\n      }\n      catch (ex) {\n        dwr.engine._handleWarning(batch, ex);\n      }\n      batch.req.send(request.body);\n      if (!batch.async) dwr.engine._stateChange(batch);\n    }\n    catch (ex) {\n      dwr.engine._handleError(batch, ex);\n    }\n  }\n  else if (batch.rpcType != dwr.engine.ScriptTag) {\n    var idname = batch.isPoll ? "dwr-if-poll-" + batch.map.batchId : "dwr-if-" + batch.map.batchId;\n    // Removed htmlfile implementation. Don\'t expect it to return before v3\n    batch.div = document.createElement("div");\n    // Add the div to the document first, otherwise IE 6 will ignore onload handler.\n    document.body.appendChild(batch.div);\n    batch.div.innerHTML = "<iframe src=\'javascript:void(0)\' frameborder=\'0\' style=\'width:0px;height:0px;border:0;\' id=\'" + idname + "\' name=\'" + idname + "\' onload=\'dwr.engine._iframeLoadingComplete (" + batch.map.batchId + ");\'></iframe>";\n    batch.document = document;\n    batch.iframe = batch.document.getElementById(idname);\n    batch.iframe.batch = batch;\n    batch.mode = batch.isPoll ? dwr.engine._ModeHtmlPoll : dwr.engine._ModeHtmlCall;\n    if (batch.isPoll) dwr.engine._outstandingIFrames.push(batch.iframe);\n    request = dwr.engine._constructRequest(batch);\n    if (batch.httpMethod == "GET") {\n      batch.iframe.setAttribute("src", request.url);\n    }\n    else {\n      batch.form = batch.document.createElement("form");\n      batch.form.setAttribute("id", "dwr-form");\n      batch.form.setAttribute("action", request.url);\n      batch.form.setAttribute("style", "display:none;");\n      batch.form.setAttribute("target", idname);\n      batch.form.target = idname;\n      batch.form.setAttribute("method", batch.httpMethod);\n      for (prop in batch.map) {\n        var value = batch.map[prop];\n        if (typeof value != "function") {\n          var formInput = batch.document.createElement("input");\n          formInput.setAttribute("type", "hidden");\n          formInput.setAttribute("name", prop);\n          formInput.setAttribute("value", value);\n          batch.form.appendChild(formInput);\n        }\n      }\n      batch.document.body.appendChild(batch.form);\n      batch.form.submit();\n    }\n  }\n  else {\n    batch.httpMethod = "GET"; // There\'s no such thing as ScriptTag using POST\n    batch.mode = batch.isPoll ? dwr.engine._ModePlainPoll : dwr.engine._ModePlainCall;\n    request = dwr.engine._constructRequest(batch);\n    batch.script = document.createElement("script");\n    batch.script.id = "dwr-st-" + batch.map["c0-id"];\n    batch.script.src = request.url;\n    document.body.appendChild(batch.script);\n  }\n};\n\ndwr.engine._ModePlainCall = "/call/plaincall/";\ndwr.engine._ModeHtmlCall = "/call/htmlcall/";\ndwr.engine._ModePlainPoll = "/call/plainpoll/";\ndwr.engine._ModeHtmlPoll = "/call/htmlpoll/";\n\n/** @private Work out what the URL should look like */\ndwr.engine._constructRequest = function(batch) {\n  // A quick string to help people that use web log analysers\n  var request = { url:batch.path + batch.mode, body:null };\n  if (batch.isPoll == true) {\n    request.url += "ReverseAjax.dwr";\n  }\n  else if (batch.map.callCount == 1) {\n    request.url += batch.map["c0-scriptName"] + "." + batch.map["c0-methodName"] + ".dwr";\n  }\n  else {\n    request.url += "Multiple." + batch.map.callCount + ".dwr";\n  }\n  // Play nice with url re-writing\n  var sessionMatch = location.href.match(/jsessionid=([^?]+)/);\n  if (sessionMatch != null) {\n    request.url += ";jsessionid=" + sessionMatch[1];\n  }\n\n  var prop;\n  if (batch.httpMethod == "GET") {\n    // Some browsers (Opera/Safari2) seem to fail to convert the callCount value\n    // to a string in the loop below so we do it manually here.\n    batch.map.callCount = "" + batch.map.callCount;\n    request.url += "?";\n    for (prop in batch.map) {\n      if (typeof batch.map[prop] != "function") {\n        request.url += encodeURIComponent(prop) + "=" + encodeURIComponent(batch.map[prop]) + "&";\n      }\n    }\n    request.url = request.url.substring(0, request.url.length - 1);\n  }\n  else {\n    // PERFORMANCE: for iframe mode this is thrown away.\n    request.body = "";\n    if (document.all && !window.opera) {\n      // Use array joining on IE (fastest)\n      var buf = [];\n      for (prop in batch.map) {\n        if (typeof batch.map[prop] != "function") {\n          buf.push(prop + "=" + batch.map[prop] + dwr.engine._postSeperator);\n        }\n      }\n      request.body = buf.join("");\n    }\n    else {\n      // Use string concat on other browsers (fastest)\n      for (prop in batch.map) {\n        if (typeof batch.map[prop] != "function") {\n          request.body += prop + "=" + batch.map[prop] + dwr.engine._postSeperator;\n        }\n      }\n    }\n    request.body = dwr.engine._contentRewriteHandler(request.body);\n  }\n  request.url = dwr.engine._urlRewriteHandler(request.url);\n  return request;\n};\n\n/** @private Called by XMLHttpRequest to indicate that something has happened */\ndwr.engine._stateChange = function(batch) {\n  var toEval;\n\n  if (batch.completed) {\n    dwr.engine._debug("Error: _stateChange() with batch.completed");\n    return;\n  }\n\n  var req = batch.req;\n  try {\n    if (req.readyState != 4) return;\n  }\n  catch (ex) {\n    dwr.engine._handleWarning(batch, ex);\n    // It\'s broken - clear up and forget this call\n    dwr.engine._clearUp(batch);\n    return;\n  }\n\n  if (dwr.engine._unloading) {\n    dwr.engine._debug("Ignoring reply from server as page is unloading.");\n    return;\n  }\n\n  try {\n    var reply = req.responseText;\n    reply = dwr.engine._replyRewriteHandler(reply);\n    var status = req.status; // causes Mozilla to except on page moves\n\n    if (reply == null || reply == "") {\n      dwr.engine._handleWarning(batch, { name:"dwr.engine.missingData", message:"No data received from server" });\n    }\n    else if (status != 200) {\n      dwr.engine._handleError(batch, { name:"dwr.engine.http." + status, message:req.statusText });\n    }\n    else {\n      var contentType = req.getResponseHeader("Content-Type");\n      if (!contentType.match(/^text\\/plain/) && !contentType.match(/^text\\/javascript/)) {\n        if (contentType.match(/^text\\/html/) && typeof batch.textHtmlHandler == "function") {\n          batch.textHtmlHandler({ status:status, responseText:reply, contentType:contentType });\n        }\n        else {\n          dwr.engine._handleWarning(batch, { name:"dwr.engine.invalidMimeType", message:"Invalid content type: \'" + contentType + "\'" });\n        }\n      }\n      else {\n        // Comet replies might have already partially executed\n        if (batch.isPoll && batch.map.partialResponse == dwr.engine._partialResponseYes) {\n          dwr.engine._processCometResponse(reply, batch);\n        }\n        else {\n          if (reply.search("//#DWR") == -1) {\n            dwr.engine._handleWarning(batch, { name:"dwr.engine.invalidReply", message:"Invalid reply from server" });\n          }\n          else {\n            toEval = reply;\n          }\n        }\n      }\n    }\n  }\n  catch (ex) {\n    dwr.engine._handleWarning(batch, ex);\n  }\n\n  dwr.engine._callPostHooks(batch);\n\n  // Outside of the try/catch so errors propogate normally:\n  dwr.engine._receivedBatch = batch;\n  if (toEval != null) toEval = toEval.replace(dwr.engine._scriptTagProtection, "");\n  dwr.engine._eval(toEval);\n  dwr.engine._receivedBatch = null;\n  dwr.engine._validateBatch(batch);\n  if (!batch.completed) dwr.engine._clearUp(batch);\n};\n\n/**\n * @private This function is invoked when a batch reply is received.\n * It checks that there is a response for every call in the batch. Otherwise,\n * an error will be signaled (a call without a response indicates that the\n * server failed to send complete batch response).\n */\ndwr.engine._validateBatch = function(batch) {\n  // If some call left unreplied, report an error.\n  if (!batch.completed) {\n    for (var i = 0; i < batch.map.callCount; i++) {\n      if (batch.handlers[i] != null) {\n        dwr.engine._handleWarning(batch, { name:"dwr.engine.incompleteReply", message:"Incomplete reply from server" });\n        break;\n      }\n    }\n  }\n}\n\n/** @private Called from iframe onload, check batch using batch-id */\ndwr.engine._iframeLoadingComplete = function(batchId) {\n  // dwr.engine._checkCometPoll();\n  var batch = dwr.engine._batches[batchId];\n  if (batch) dwr.engine._validateBatch(batch);\n}\n\n/** @private Called by the server: Execute a callback */\ndwr.engine._remoteHandleCallback = function(batchId, callId, reply) {\n  var batch = dwr.engine._batches[batchId];\n  if (batch == null) {\n    dwr.engine._debug("Warning: batch == null in remoteHandleCallback for batchId=" + batchId, true);\n    return;\n  }\n  // Error handlers inside here indicate an error that is nothing to do\n  // with DWR so we handle them differently.\n  try {\n    var handlers = batch.handlers[callId];\n    batch.handlers[callId] = null;\n    if (!handlers) {\n      dwr.engine._debug("Warning: Missing handlers. callId=" + callId, true);\n    }\n    else if (typeof handlers.callback == "function") handlers.callback(reply);\n  }\n  catch (ex) {\n    dwr.engine._handleError(batch, ex);\n  }\n};\n\n/** @private Called by the server: Handle an exception for a call */\ndwr.engine._remoteHandleException = function(batchId, callId, ex) {\n  var batch = dwr.engine._batches[batchId];\n  if (batch == null) { dwr.engine._debug("Warning: null batch in remoteHandleException", true); return; }\n  var handlers = batch.handlers[callId];\n  batch.handlers[callId] = null;\n  if (handlers == null) { dwr.engine._debug("Warning: null handlers in remoteHandleException", true); return; }\n  if (ex.message == undefined) ex.message = "";\n  if (typeof handlers.exceptionHandler == "function") handlers.exceptionHandler(ex.message, ex);\n  else if (typeof batch.errorHandler == "function") batch.errorHandler(ex.message, ex);\n};\n\n/** @private Called by the server: The whole batch is broken */\ndwr.engine._remoteHandleBatchException = function(ex, batchId) {\n  var searchBatch = (dwr.engine._receivedBatch == null && batchId != null);\n  if (searchBatch) {\n    dwr.engine._receivedBatch = dwr.engine._batches[batchId];\n  }\n  if (ex.message == undefined) ex.message = "";\n  dwr.engine._handleError(dwr.engine._receivedBatch, ex);\n  if (searchBatch) {\n    dwr.engine._receivedBatch = null;\n    dwr.engine._clearUp(dwr.engine._batches[batchId]);\n  }\n};\n\n/** @private Called by the server: Reverse ajax should not be used */\ndwr.engine._remotePollCometDisabled = function(ex, batchId) {\n  dwr.engine.setActiveReverseAjax(false);\n  var searchBatch = (dwr.engine._receivedBatch == null && batchId != null);\n  if (searchBatch) {\n    dwr.engine._receivedBatch = dwr.engine._batches[batchId];\n  }\n  if (ex.message == undefined) ex.message = "";\n  dwr.engine._handleError(dwr.engine._receivedBatch, ex);\n  if (searchBatch) {\n    dwr.engine._receivedBatch = null;\n    dwr.engine._clearUp(dwr.engine._batches[batchId]);\n  }\n};\n\n/** @private Called by the server: An IFrame reply is about to start */\ndwr.engine._remoteBeginIFrameResponse = function(iframe, batchId) {\n  if (iframe != null) dwr.engine._receivedBatch = iframe.batch;\n  dwr.engine._callPostHooks(dwr.engine._receivedBatch);\n};\n\n/** @private Called by the server: An IFrame reply is just completing */\ndwr.engine._remoteEndIFrameResponse = function(batchId) {\n  dwr.engine._clearUp(dwr.engine._receivedBatch);\n  dwr.engine._receivedBatch = null;\n};\n\n/** @private This is a hack to make the context be this window */\ndwr.engine._eval = function(script) {\n  if (script == null) return null;\n  if (script == "") { dwr.engine._debug("Warning: blank script", true); return null; }\n  // dwr.engine._debug("Exec: [" + script + "]", true);\n  return eval(script);\n};\n\n/** @private Called as a result of a request timeout */\ndwr.engine._abortRequest = function(batch) {\n  if (batch && !batch.completed) {\n    dwr.engine._clearUp(batch);\n    if (batch.req) batch.req.abort();\n    dwr.engine._handleError(batch, { name:"dwr.engine.timeout", message:"Timeout" });\n  }\n};\n\n/** @private call all the post hooks for a batch */\ndwr.engine._callPostHooks = function(batch) {\n  if (batch.postHooks) {\n    for (var i = 0; i < batch.postHooks.length; i++) {\n      batch.postHooks[i]();\n    }\n    batch.postHooks = null;\n  }\n};\n\n/** @private A call has finished by whatever means and we need to shut it all down. */\ndwr.engine._clearUp = function(batch) {\n  if (!batch) { dwr.engine._debug("Warning: null batch in dwr.engine._clearUp()", true); return; }\n  if (batch.completed) { dwr.engine._debug("Warning: Double complete", true); return; }\n\n  // IFrame tidyup\n  if (batch.div) batch.div.parentNode.removeChild(batch.div);\n  if (batch.iframe) {\n    // If this is a poll frame then stop comet polling\n    for (var i = 0; i < dwr.engine._outstandingIFrames.length; i++) {\n      if (dwr.engine._outstandingIFrames[i] == batch.iframe) {\n        dwr.engine._outstandingIFrames.splice(i, 1);\n      }\n    }\n    batch.iframe.parentNode.removeChild(batch.iframe);\n  }\n  if (batch.form) batch.form.parentNode.removeChild(batch.form);\n\n  // XHR tidyup: avoid IE handles increase\n  if (batch.req) {\n    // If this is a poll frame then stop comet polling\n    if (batch.req == dwr.engine._pollReq) dwr.engine._pollReq = null;\n    delete batch.req;\n  }\n\n  // Timeout tidyup\n  if (batch.timeoutId) {\n    clearTimeout(batch.timeoutId);\n    delete batch.timeoutId;\n  }\n\n  if (batch.map && (batch.map.batchId || batch.map.batchId == 0)) {\n    delete dwr.engine._batches[batch.map.batchId];\n    dwr.engine._batchesLength--;\n  }\n\n  batch.completed = true;\n\n  // If there is anything on the queue waiting to go out, then send it.\n  // We don\'t need to check for ordered mode, here because when ordered mode\n  // gets turned off, we still process *waiting* batches in an ordered way.\n  if (dwr.engine._batchQueue.length != 0) {\n    var sendbatch = dwr.engine._batchQueue.shift();\n    dwr.engine._sendData(sendbatch);\n  }\n};\n\n/** @private Abort any XHRs in progress at page unload (solves zombie socket problems in IE). */\ndwr.engine._unloader = function() {\n  dwr.engine._unloading = true;\n\n  // Empty queue of waiting ordered requests\n  dwr.engine._batchQueue.length = 0;\n\n  // Abort any ongoing XHRs and clear their batches\n  for (var batchId in dwr.engine._batches) {\n    var batch = dwr.engine._batches[batchId];\n    // Only process objects that look like batches (avoid prototype additions!)\n    if (batch && batch.map) {\n      if (batch.req) {\n        batch.req.abort();\n      }\n      dwr.engine._clearUp(batch);\n    }\n  }\n};\n// Now register the unload handler\nif (window.addEventListener) window.addEventListener(\'unload\', dwr.engine._unloader, false);\nelse if (window.attachEvent) window.attachEvent(\'onunload\', dwr.engine._unloader);\n\n/** @private Generic error handling routing to save having null checks everywhere */\ndwr.engine._handleError = function(batch, ex) {\n  if (typeof ex == "string") ex = { name:"unknown", message:ex };\n  if (ex.message == null) ex.message = "";\n  if (ex.name == null) ex.name = "unknown";\n  if (batch && typeof batch.errorHandler == "function") batch.errorHandler(ex.message, ex);\n  else if (dwr.engine._errorHandler) dwr.engine._errorHandler(ex.message, ex);\n  if (batch) dwr.engine._clearUp(batch);\n};\n\n/** @private Generic error handling routing to save having null checks everywhere */\ndwr.engine._handleWarning = function(batch, ex) {\n  if (typeof ex == "string") ex = { name:"unknown", message:ex };\n  if (ex.message == null) ex.message = "";\n  if (ex.name == null) ex.name = "unknown";\n  if (batch && typeof batch.warningHandler == "function") batch.warningHandler(ex.message, ex);\n  else if (dwr.engine._warningHandler) dwr.engine._warningHandler(ex.message, ex);\n  if (batch) dwr.engine._clearUp(batch);\n};\n\n/**\n * @private Marshall a data item\n * @param batch A map of variables to how they have been marshalled\n * @param referto An array of already marshalled variables to prevent recurrsion\n * @param data The data to be marshalled\n * @param name The name of the data being marshalled\n */\ndwr.engine._serializeAll = function(batch, referto, data, name) {\n  if (data == null) {\n    batch.map[name] = "null:null";\n    return;\n  }\n\n  switch (typeof data) {\n  case "boolean":\n    batch.map[name] = "boolean:" + data;\n    break;\n  case "number":\n    batch.map[name] = "number:" + data;\n    break;\n  case "string":\n    batch.map[name] = "string:" + encodeURIComponent(data);\n    break;\n  case "object":\n    if (data instanceof String) batch.map[name] = "String:" + encodeURIComponent(data);\n    else if (data instanceof Boolean) batch.map[name] = "Boolean:" + data;\n    else if (data instanceof Number) batch.map[name] = "Number:" + data;\n    else if (data instanceof Date) batch.map[name] = "Date:" + data.getTime();\n    else if (data && data.join) batch.map[name] = dwr.engine._serializeArray(batch, referto, data, name);\n    else batch.map[name] = dwr.engine._serializeObject(batch, referto, data, name);\n    break;\n  case "function":\n    // We just ignore functions.\n    break;\n  default:\n    dwr.engine._handleWarning(null, { name:"dwr.engine.unexpectedType", message:"Unexpected type: " + typeof data + ", attempting default converter." });\n    batch.map[name] = "default:" + data;\n    break;\n  }\n};\n\n/** @private Have we already converted this object? */\ndwr.engine._lookup = function(referto, data, name) {\n  var lookup;\n  // Can\'t use a map: getahead.org/ajax/javascript-gotchas\n  for (var i = 0; i < referto.length; i++) {\n    if (referto[i].data == data) {\n      lookup = referto[i];\n      break;\n    }\n  }\n  if (lookup) return "reference:" + lookup.name;\n  referto.push({ data:data, name:name });\n  return null;\n};\n\n/** @private Marshall an object */\ndwr.engine._serializeObject = function(batch, referto, data, name) {\n  var ref = dwr.engine._lookup(referto, data, name);\n  if (ref) return ref;\n\n  // This check for an HTML is not complete, but is there a better way?\n  // Maybe we should add: data.hasChildNodes typeof "function" == true\n  if (data.nodeName && data.nodeType) {\n    return dwr.engine._serializeXml(batch, referto, data, name);\n  }\n\n  // treat objects as an associative arrays\n  var reply = "Object_" + dwr.engine._getObjectClassName(data) + ":{";\n  var element;\n  for (element in data) {\n    if (typeof data[element] != "function") {\n      batch.paramCount++;\n      var childName = "c" + dwr.engine._batch.map.callCount + "-e" + batch.paramCount;\n      dwr.engine._serializeAll(batch, referto, data[element], childName);\n\n      reply += encodeURIComponent(element) + ":reference:" + childName + ", ";\n    }\n  }\n\n  if (reply.substring(reply.length - 2) == ", ") {\n    reply = reply.substring(0, reply.length - 2);\n  }\n  reply += "}";\n\n  return reply;\n};\n\n/** @private Returns the classname of supplied argument obj */\ndwr.engine._errorClasses = { "Error":Error, "EvalError":EvalError, "RangeError":RangeError, "ReferenceError":ReferenceError, "SyntaxError":SyntaxError, "TypeError":TypeError, "URIError":URIError };\ndwr.engine._getObjectClassName = function(obj) {\n  // Try to find the classname by stringifying the object\'s constructor\n  // and extract <class> from "function <class>".\n  if (obj && obj.constructor && obj.constructor.toString)\n  {\n    var str = obj.constructor.toString();\n    var regexpmatch = str.match(/function\\s+(\\w+)/);\n    if (regexpmatch && regexpmatch.length == 2) {\n      return regexpmatch[1];\n    }\n  }\n\n  // Now manually test against the core Error classes, as these in some\n  // browsers successfully match to the wrong class in the\n  // Object.toString() test we will do later\n  if (obj && obj.constructor) {\n\tfor (var errorname in dwr.engine._errorClasses) {\n      if (obj.constructor == dwr.engine._errorClasses[errorname]) return errorname;\n    }\n  }\n\n  // Try to find the classname by calling Object.toString() on the object\n  // and extracting <class> from "[object <class>]"\n  if (obj) {\n    var str = Object.prototype.toString.call(obj);\n    var regexpmatch = str.match(/\\[object\\s+(\\w+)/);\n    if (regexpmatch && regexpmatch.length==2) {\n      return regexpmatch[1];\n    }\n  }\n\n  // Supplied argument was probably not an object, but what is better?\n  return "Object";\n};\n\n/** @private Marshall an object */\ndwr.engine._serializeXml = function(batch, referto, data, name) {\n  var ref = dwr.engine._lookup(referto, data, name);\n  if (ref) return ref;\n\n  var output;\n  if (window.XMLSerializer) output = new XMLSerializer().serializeToString(data);\n  else if (data.toXml) output = data.toXml;\n  else output = data.innerHTML;\n\n  return "XML:" + encodeURIComponent(output);\n};\n\n/** @private Marshall an array */\ndwr.engine._serializeArray = function(batch, referto, data, name) {\n  var ref = dwr.engine._lookup(referto, data, name);\n  if (ref) return ref;\n\n  if (document.all && !window.opera) {\n    // Use array joining on IE (fastest)\n    var buf = ["Array:["];\n    for (var i = 0; i < data.length; i++) {\n      if (i != 0) buf.push(",");\n      batch.paramCount++;\n      var childName = "c" + dwr.engine._batch.map.callCount + "-e" + batch.paramCount;\n      dwr.engine._serializeAll(batch, referto, data[i], childName);\n      buf.push("reference:");\n      buf.push(childName);\n    }\n    buf.push("]");\n    reply = buf.join("");\n  }\n  else {\n    // Use string concat on other browsers (fastest)\n    var reply = "Array:[";\n    for (var i = 0; i < data.length; i++) {\n      if (i != 0) reply += ",";\n      batch.paramCount++;\n      var childName = "c" + dwr.engine._batch.map.callCount + "-e" + batch.paramCount;\n      dwr.engine._serializeAll(batch, referto, data[i], childName);\n      reply += "reference:";\n      reply += childName;\n    }\n    reply += "]";\n  }\n\n  return reply;\n};\n\n/** @private Convert an XML string into a DOM object. */\ndwr.engine._unserializeDocument = function(xml) {\n  var dom;\n  if (window.DOMParser) {\n    var parser = new DOMParser();\n    dom = parser.parseFromString(xml, "text/xml");\n    if (!dom.documentElement || dom.documentElement.tagName == "parsererror") {\n      var message = dom.documentElement.firstChild.data;\n      message += "\\n" + dom.documentElement.firstChild.nextSibling.firstChild.data;\n      throw message;\n    }\n    return dom;\n  }\n  else if (window.ActiveXObject) {\n    dom = dwr.engine._newActiveXObject(dwr.engine._DOMDocument);\n    dom.loadXML(xml); // What happens on parse fail with IE?\n    return dom;\n  }\n  else {\n    var div = document.createElement("div");\n    div.innerHTML = xml;\n    return div;\n  }\n};\n\n/** @param axarray An array of strings to attempt to create ActiveX objects from */\ndwr.engine._newActiveXObject = function(axarray) {\n  var returnValue;\n  for (var i = 0; i < axarray.length; i++) {\n    try {\n      returnValue = new ActiveXObject(axarray[i]);\n      break;\n    }\n    catch (ex) { /* ignore */ }\n  }\n  return returnValue;\n};\n\n/** @private Used internally when some message needs to get to the programmer */\ndwr.engine._debug = function(message, stacktrace) {\n  var written = false;\n  try {\n    if (window.console) {\n      if (stacktrace && window.console.trace) window.console.trace();\n      window.console.log(message);\n      written = true;\n    }\n    else if (window.opera && window.opera.postError) {\n      window.opera.postError(message);\n      written = true;\n    }\n  }\n  catch (ex) { /* ignore */ }\n\n  if (!written) {\n    var debug = document.getElementById("dwr-debug");\n    if (debug) {\n      var contents = message + "<br/>" + debug.innerHTML;\n      if (contents.length > 2048) contents = contents.substring(0, 2048);\n      debug.innerHTML = contents;\n    }\n  }\n};\n\n'