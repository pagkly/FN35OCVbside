b'blob 161378\x00var widget =\n{};\n\nwidget.colorPickers =\n{};\n\nwidget.ColorPicker = Class.create();\n\nwidget.ColorPicker.prototype =\n{\n    /**\n     * Constructor\n     *\n     * @param name - id of the color picker\n     * @param initialColor - initial color hex string ("#000000")\n     * @param alertMsg - localized error msg string ("Error: A valid color value must be specified")\n     * @param previewIdStr - optional id string of the color preview DIV container user can specify\n     * @param allowTransparent - optional boolean whether to render an option to select transparent. Default is false.\n     */\n    initialize : function( name, initialColor, alertMsg, previewIdStr, previewBackgroundIdStr, allowTransparent )\n    {\n      this.theColorPickerName = name;\n      this.allowTransparent = ( !allowTransparent ) ? false : true;\n      this.theMenu = $( name );\n      this.alertMsg = alertMsg;\n      this.userPreviewContainer = $( previewIdStr ); // may be undefined\n      this.userPreviewBackgroundContainer = $( previewBackgroundIdStr ); // may be undefined\n      if ( typeof this.userPreviewContainer == "undefined" )\n      {\n        this.userPreviewContainer = null;\n      }\n      if ( typeof this.userPreviewBackgroundContainer == "undefined" )\n      {\n        this.userPreviewBackgroundContainer = null;\n      }\n      this.colorListParent = $( name + \'_colorlist_parent\' );\n\n      widget.ColorPicker.registerColorPicker( this );\n\n      this.ie = document.all && navigator.userAgent.indexOf( "Opera" ) == -1;\n      this.color_hidden_input = $( name + "_title_color_input" );\n      this.color_hidden_input.value = initialColor;\n      this.color_hidden_input._defaultValue = initialColor;\n      this.anch_link = $( name + "_link" );\n      this.color_link = $( name + "_img" );\n      this.color_name_label = $( name + "_color_name_label" );\n      this.title_color_input = $( name + "_title_color" );\n      this.setDisplay( initialColor, this.getDisplayColorInfo( initialColor, false ) );\n      this.color_name_label.innerHTML = this.getDisplayColorInfo( initialColor, true );\n      var backgroundStyle = initialColor;\n      if( initialColor === "transparent" )\n      {\n        backgroundStyle = \'url(\' + getCdnURL( "/images/swatches/transparent.gif" ) + \')\';\n      }\n      this.color_link.setStyle(\n      {\n        background : backgroundStyle\n      } );\n      this.updateUserPreviewContainerColor( initialColor );\n      if ( this.anch_link )\n      {\n        Event.observe( this.anch_link, "click", this.onOpen.bindAsEventListener( this ) );\n      }\n      Event.observe( document.body, "click", this.closeColorPickers.bindAsEventListener( this ) );\n      Event.observe( this.theMenu, \'keydown\', this.onKeyPress.bindAsEventListener( this ) );\n      Event.observe( this.theColorPickerName + \'_previewColorLink\', \'click\', this.previewListener\n          .bindAsEventListener( this ) );\n      Event.observe( this.theColorPickerName + \'_cancelButton\', \'click\', this.onClose.bindAsEventListener( this ) );\n      Event.observe( this.theColorPickerName + \'_submitButton\', \'click\', this.onApply.bindAsEventListener( this ) );\n\n      this.skip_link = $( name + "_skip_link" );\n      if ( this.skip_link )\n      {\n        Event.observe( this.skip_link, "click", this.onSkipLinkClick.bindAsEventListener( this ) );\n      }\n\n      // relocate color picker popup div to the bottom of the doc b/c of css display issues\n      Element.remove( this.theMenu );\n      document.body.appendChild( this.theMenu );\n\n      widget.colorPickers[ this.theColorPickerName ] = this;\n    },\n\n    onSkipLinkClick : function( event )\n    {\n      $( this.theColorPickerName + \'_submitButton\' ).focus();\n    },\n\n    onKeyPress : function( event )\n    {\n      var key = event.keyCode || event.which;\n      if ( key == Event.KEY_ESC )\n      {\n        this.onClose( event );\n      }\n    },\n\n    closeColorPickers : function( event )\n    {\n      var element = Event.element( event );\n      widget.ColorPicker.colorPickers.each( function( cp )\n      {\n        if ( cp != this && !element.descendantOf( cp.theMenu ) )\n        {\n          cp.close();\n        }\n      }.bind( this ) );\n\n    },\n    setOnChangeHandler : function( handler )\n    {\n      this.onChangeHandler = handler;\n    },\n    setDefaultColor : function( colorValue )\n    {\n      this.color_hidden_input.value = colorValue;\n      this.color_hidden_input._defaultValue = colorValue;\n      if ( colorValue === "transparent" )\n      {\n        this.color_link.setStyle(\n        {\n          background : \'url(\' + getCdnURL( "/images/swatches/transparent.gif" ) + \')\'\n        } );\n      }\n      else\n      {\n        this.color_link.setStyle(\n        {\n          background : colorValue\n        } );\n      }\n      this.setDisplay( colorValue, this.getDisplayColorInfo( colorValue, false ) );\n      this.color_name_label.innerHTML = this.getDisplayColorInfo( colorValue, true );\n    },\n    setColor : function( colorValue )\n    {\n      widget.ShowUnsavedChanges.changeHiddenValue( this.color_hidden_input, colorValue );\n      if ( colorValue === "transparent" )\n      {\n        this.color_link.setStyle(\n        {\n          background : \'url(\' + getCdnURL( "/images/swatches/transparent.gif" ) + \')\'\n        } );\n      }\n      else\n      {\n        this.color_link.setStyle(\n        {\n          background : colorValue\n        } );\n      }\n\n      this.setDisplay( colorValue, this.getDisplayColorInfo( colorValue, false ) );\n      this.color_name_label.innerHTML = this.getDisplayColorInfo( colorValue, true );\n      this.updateUserPreviewContainerColor( colorValue );\n      if ( this.onChangeHandler )\n      {\n        this.onChangeHandler();\n      }\n    },\n\n    getPaletteInstance : function()\n    {\n      if ( !this.paletteInstance )\n      {\n        this.paletteInstance = Element.clone( widget.ColorPicker.colorPalette, true );\n      }\n      return this.paletteInstance;\n    },\n\n    deletePaletteInstance : function()\n    {\n      if ( this.paletteInstance )\n      {\n        Event.stopObserving( this.paletteInstance, \'click\' );\n        this.paletteInstance.remove();\n        delete this.paletteInstance;\n      }\n    },\n\n    onOpen : function( event )\n    {\n      this.closeColorPickers( event );\n      this.colorListParent.appendChild( this.getPaletteInstance() );\n      this.initializeTransparent();\n      Event.observe( this.getPaletteInstance(), \'click\', this.setColorFromSwatch.bindAsEventListener( this ) );\n      var offset = Position.cumulativeOffset( this.anch_link );\n      this.theMenu.setStyle(\n      {\n          display : "block",\n          position : "absolute"\n      } );\n      var width = this.theMenu.getWidth();\n      var bodyWidth = $( document.body ).getWidth();\n\n      var menuDims = this.theMenu.getDimensionsEx();\n      var anchorDims = this.anch_link.getDimensionsEx();\n      var menuHeight = menuDims.height;\n      var viewportDimensions = document.viewport.getDimensions();\n      var scrollOffsets = document.viewport.getScrollOffsets();\n      // Use viewport relative offsets to figure out placement within the view\n      var offsetTop = offset[ 1 ] - scrollOffsets.top - this.anch_link.cumulativeScrollOffset()[1];\n      var offsetLeft = offset[ 0 ] - scrollOffsets.left;\n\n      var xpos = offsetLeft;\n      if ( page.util.isRTL() )\n      {\n        xpos = xpos + this.anch_link.getWidth() - width;\n      }\n      if ( xpos + width > viewportDimensions.width )\n      {\n        // First try to position it on the left of the link instead of the right\n        xpos = offsetLeft - width + anchorDims.width;\n        if ( xpos < 0 )\n        {\n          // If we go off the page though, just try our best\n          xpos = viewportDimensions.width - width;\n        }\n      }\n      if ( xpos < 0 )\n      {\n        xpos = 0;\n      }\n      var ypos = offsetTop + anchorDims.height;\n      if ( ( ypos + menuHeight ) > viewportDimensions.height )\n      {\n        // Try to position above the color picker first\n        ypos = offsetTop - menuHeight;\n        if ( ypos < 0 )\n        {\n          // but if it goes off the top of the page just do a best-effort.\n          ypos = ypos - ( ypos + menuHeight - viewportDimensions.height );\n          if ( ypos < 0 )\n          {\n            ypos = 0;\n          }\n        }\n      }\n      // The color swatch is positioned absolutely, so adjust offsets to include the scrollofset\n      ypos = ypos + (scrollOffsets.top*2);\n      xpos = xpos + scrollOffsets.left;\n      this.theMenu.setStyle(\n      {\n          left : xpos + "px",\n          top : ypos + "px"\n      } );\n      this.title_color_input.focus();\n      ( function()\n      {\n        if ( !this.shim )\n        {\n          this.shim = new page.popupShim( this.theMenu );\n        }\n        this.shim.open();\n      }.bind( this ).defer() );\n      Event.stop( event );\n    },\n\n    /**\n     * Removes the transparent choice from the palette if the picker is not supposed to support transparency.\n     */\n    initializeTransparent : function()\n    {\n      if ( !this.allowTransparent )\n      {\n        var transparentLi = this.colorListParent.down( \'li#colorlist_transparent\' );\n        if ( transparentLi )\n        {\n          Element.remove( transparentLi );\n        }\n      }\n    },\n\n    /**\n     * Hides the color picker.\n     */\n    onClose : function()\n    {\n      this.close();\n      this.anch_link.focus();\n    },\n\n    close : function()\n    {\n      this.deletePaletteInstance();\n\n      this.theMenu.setStyle(\n      {\n        display : "none"\n      } );\n      if ( this.shim )\n      {\n        this.shim.close();\n      }\n    },\n\n    /**\n     * Sets the preview color and text to the color selected by the user in the palette\n     */\n    setColorFromSwatch : function( event )\n    {\n      var element = Event.element( event );\n      if ( element.hasClassName( \'transparent\' ) )\n      {\n        this.setDisplay( "transparent", page.bundle.getString( "colorpicker.color.transparent" ) );\n      }\n      else\n      {\n        var text = element.childNodes[ 0 ].nodeValue;\n        if ( text )\n        {\n          this.setDisplay( text.substring( 0, 7 ), this.getDisplayColorInfo( text.substring( 0, 7 ), false ) );\n        }\n      }\n      Event.stop( event );\n    },\n\n    getDisplayColorInfo : function( hexValue, onlyColorName )\n    {\n      var transparent = false;\n      var localizedName;\n      var safeColorCode;\n      if ( hexValue === "transparent" )\n      {\n        transparent = true;\n        localizedName = widget.ColorPicker.colorPickerPaletteMap[ "default" ][ hexValue ];\n      }\n      else\n      {\n        safeColorCode = this.getSafeColorCode( hexValue ).toUpperCase();\n        //The keys in ColorPickerMap are all 6 digit safe color codes, that\'s we need to make sure that we\'re using the correct key to lookup the color.\n        localizedName = widget.ColorPicker.colorPickerPaletteMap[ "default" ][ safeColorCode ];\n      }\n\n      if ( !localizedName )\n      {\n        localizedName = \'\';\n      }\n      var colorName;\n      colorName = localizedName + \' (\' + hexValue + \')\';\n\n      if ( onlyColorName || transparent )\n      {\n        colorName = localizedName;\n      }\n      return colorName;\n    },\n\n\n    /**\n     * Returns a Six digit Hexadecimal Color Code.\n     */\n    getSafeColorCode : function( hexValue )\n    {\n      return hexValue.replace( /#([\\d0-9A-Fa-f])([\\d0-9A-Fa-f])([\\d0-9A-Fa-f])$/,\'#$1$1$2$2$3$3\');\n    },\n\n\n    /**\n     * Handles the Preview functionality on the swatch. If an inappropriate color is choosen, a msg is displayed to the\n     * user. Else updates the color preview with the manually entered color.\n     */\n    previewListener : function( event )\n    {\n      if ( !this.isValidColor( this.title_color_input.value ) )\n      {\n        alert( this.alertMsg );\n        return;\n      }\n      if ( this.title_color_input.value.length != 6 )\n      {\n        return;\n      }\n      var prevCol;\n\n      if ( this.title_color_input.value.toLowerCase() === "xxxxxx" )\n      {\n        prevCol = "transparent";\n        this.setDisplay( prevCol, page.bundle.getString( \'colorpicker.color.transparent\' ) );\n      }\n      else\n      {\n        prevCol = \'#\' + this.title_color_input.value;\n        this.setDisplay( prevCol, this.getDisplayColorInfo( prevCol, false ) );\n      }\n\n      Event.stop( event );\n    },\n\n    /**\n     * Updates the color preview panel in the picker pop up\n     */\n    setDisplay : function( col, text )\n    {\n      if ( col === "transparent" )\n      {\n        $( this.theColorPickerName + \'_swatchpreview\' ).setStyle(\n        {\n          background : \'url(\' + getCdnURL( "/images/swatches/transparent_lrg.gif" ) + \')\'\n        } );\n        $( this.theColorPickerName + \'_color_text\' ).setStyle(\n        {\n          color : \'#ffffff\'\n        } );\n        this.title_color_input.value = \'XXXXXX\';\n      }\n      else\n      {\n        $( this.theColorPickerName + \'_swatchpreview\' ).setStyle(\n        {\n          background : col\n        } );\n        $( this.theColorPickerName + \'_color_text\' ).setStyle(\n        {\n          color : col\n        } );\n        this.title_color_input.value = ( col.startsWith( \'#\' ) ) ? col.substr( 1 ) : col;\n      }\n\n      $( this.theColorPickerName + \'_title_color_name\' ).innerHTML = text;\n    },\n\n    /**\n     * Checks for a valid color value.\n     */\n    isValidColor : function( color_value )\n    {\n      var isValid = false;\n\n      isValid = ( /^[0-9A-Fa-f]{6}/ ).test( color_value );\n      if ( !isValid && this.allowTransparent )\n      {\n        isValid = color_value.toLowerCase() === "xxxxxx";\n      }\n      return isValid;\n    },\n\n    /**\n     * Manages the functionality for the Apply button the swatch.\n     */\n    onApply : function( event )\n    {\n      var color = this.title_color_input.value;\n      if ( !this.isValidColor( color ) )\n      {\n        return;\n      }\n\n      if ( this.title_color_input.value.toLowerCase() === "xxxxxx" )\n      {\n        this.color_link.setStyle(\n        {\n          background : \'url(\' + getCdnURL( "/images/swatches/transparent.gif" ) + \')\'\n        } );\n        color = "transparent";\n        this.color_name_label.innerHTML = page.bundle.getString( "colorpicker.color.transparent" );\n      }\n      else\n      {\n        color = \'#\' + color;\n        this.color_link.setStyle(\n        {\n          background : color\n        } );\n        this.color_name_label.innerHTML = this.getDisplayColorInfo( color, true );\n      }\n\n      widget.ShowUnsavedChanges.changeHiddenValue( this.color_hidden_input, color );\n\n      this.updateUserPreviewContainerColor( color );\n      this.onClose();\n      if ( this.onChangeHandler )\n      {\n        this.onChangeHandler();\n      }\n      Event.stop( event );\n    },\n\n    /**\n     * If the user specified preview container element exists, update its color style to the color given.\n     *\n     * @param color - color hex string\n     */\n    updateUserPreviewContainerColor : function( color )\n    {\n      if ( this.userPreviewContainer )\n      {\n        this.userPreviewContainer.style.color = color;\n      }\n      else if ( this.userPreviewBackgroundContainer )\n      {\n        this.userPreviewBackgroundContainer.style.background = color;\n      }\n    }\n\n}; // end widget.ColorPicker.prototype\n\nwidget.ColorPicker.colorPickers = [];\nwidget.ColorPicker.colorPickerMap =\n{};\nwidget.ColorPicker.colorPickerPaletteMap =\n{};\n\nwidget.ColorPicker.registerColorPicker = function( cp )\n{\n  widget.ColorPicker.colorPickers.push( cp );\n  widget.ColorPicker.colorPickerMap[ cp.theColorPickerName ] = cp;\n  // grab the color definition and remove it from the DOM for the time being\n  if ( !widget.ColorPicker.colorPalette )\n  {\n    var colorPalette = $( \'picker_colorlist\' );\n\n    // Store the colors and their localized names so we can look them up later.\n    widget.ColorPicker.colorPickerPaletteMap[ "default" ] =\n    {};\n    var arrColors = Element.getElementsBySelector( colorPalette, "a" );\n    for ( var i = 0; i < arrColors.length; i++ )\n    {\n      if ( !arrColors[ i ].hasClassName( "transparent" ) )\n      {\n        widget.ColorPicker.colorPickerPaletteMap[ "default" ][ arrColors[ i ].innerHTML.substring( 0, 7 ).toUpperCase() ] = arrColors[ i ].innerHTML\n            .substring( 8 );\n      }\n    }\n    widget.ColorPicker.colorPickerPaletteMap[ "default" ].transparent = page.bundle\n        .getString( "colorpicker.color.transparent" );\n\n    widget.ColorPicker.colorPalette = colorPalette;\n    // deferring so that the name lookup for colors can succeed during init\n    ( function()\n    {\n      Element.remove( colorPalette );\n    }.defer() );\n  }\n};\n\nwidget.ColorPicker.closeAllColorPickers = function()\n{\n  widget.ColorPicker.colorPickers.each( function( cp )\n  {\n    cp.close();\n  } );\n};\n\nwidget.MultiSelect = Class.create();\n\nwidget.MultiSelect.multiselectBoxes = [];\n\n// ---------------- "static" methods\n\nwidget.MultiSelect.registerMultiSelect = function( ms )\n{\n  widget.MultiSelect.multiselectBoxes.push( ms );\n};\n\nwidget.MultiSelect.unRegisterMultiSelect = function( ms )\n{\n  widget.MultiSelect.multiselectBoxes.remove( ms );\n};\n\nwidget.MultiSelect.prototype =\n{\n    initialize : function( multiSelectDiv, formName )\n    {\n      this.multiSelectDiv = $( multiSelectDiv );\n      this.formName = formName;\n\n      if ( this.multiSelectDiv )\n      {\n        this.leftClickListeners = [];\n        this.rightClickListeners = [];\n        var divs = this.multiSelectDiv.getElementsByTagName( \'div\' );\n        var leftDiv = $( divs[ 0 ] );\n        var buttonDiv = $( divs[ 1 ] );\n        var rightDiv = $( divs[ 2 ] );\n\n        var inputs = this.multiSelectDiv.getElementsByTagName( \'input\' );\n        this.leftValues = $( inputs[ 0 ] );\n        this.rightValues = $( inputs[ 1 ] );\n        var leftSelects = leftDiv.getElementsByTagName( \'select\' );\n        var rightSelects = rightDiv.getElementsByTagName( \'select\' );\n        this.leftSelectBox = $( leftSelects[ 0 ] );\n        this.rightSelectBox = $( rightSelects[ 0 ] );\n\n        var buttons = buttonDiv.getElementsByTagName( \'button\' );\n        var moveRightButton = $( buttons[ 0 ] );\n        var moveLeftButton = $( buttons[ 1 ] );\n        var leftInputs = leftDiv.getElementsByTagName( \'input\' );\n        var leftInvertSelectionButton = $( leftInputs[ 0 ] );\n        var leftSelectAllButton = $( leftInputs[ 1 ] );\n        var rightInputs = rightDiv.getElementsByTagName( \'input\' );\n        var rightInvertSelectionButton = $( rightInputs[ 0 ] );\n        var rightSelectAllButton = $( rightInputs[ 1 ] );\n        widget.MultiSelect.registerMultiSelect( this );\n        Event.observe( moveLeftButton, "click", this.onMoveLeftClick.bindAsEventListener( this ) );\n        Event.observe( moveRightButton, "click", this.onMoveRightClick.bindAsEventListener( this ) );\n        Event.observe( leftInvertSelectionButton, "click", this.onInvertSelection.bindAsEventListener( this, true ) );\n        Event.observe( rightInvertSelectionButton, "click", this.onInvertSelection.bindAsEventListener( this, false ) );\n        Event.observe( leftSelectAllButton, "click", this.onSelectAllClick.bindAsEventListener( this, true ) );\n        Event.observe( rightSelectAllButton, "click", this.onSelectAllClick.bindAsEventListener( this, false ) );\n\n        // This for the MultiSelectAction Bean.\n        // If actionBean list is less than 1, button is displayed and not the dropdown\n        if ( leftSelects.length > 1 )\n        {\n          this.actionBeanLeftSelect = $( leftSelects[ 1 ] );\n          this.actionBeanRightSelect = $( rightSelects[ 1 ] );\n          var actionBeanLeftGoBox = $( leftInputs[ 2 ] );\n          var actionBeanRightGoBox = $( leftInputs[ 2 ] );\n          Event.observe( actionBeanLeftGoBox, "click", this.actionBeanFunc.bindAsEventListener( this, true ) );\n          Event.observe( actionBeanRightGoBox, "click", this.actionBeanFunc.bindAsEventListener( this, false ) );\n        }\n      }\n    },\n    actionBeanFunc : function( event, leftSelect )\n    {\n      var destination = this.actionBeanLeftSelect;\n      var selectedBox = this.leftSelectBox;\n      if ( !leftSelect )\n      {\n        destination = this.actionBeanRightSelect;\n        selectedBox = this.rightSelectBox;\n      }\n      var myindex = destination.selectedIndex;\n      if ( myindex == -1 || myindex > destination.length - 1 )\n      {\n        alert( page.bundle.getString( "admin.manageuserlists.selectionwarning" ) );\n        return false;\n      }\n      var sFunctionName = destination.options[ myindex ].value;\n      var oFunc = window[ sFunctionName ];\n      oFunc( selectedBox.name, this.formName );\n      this.setHiddenValues();\n    },\n    /*\n     * listener registration for leftmove and rightmove clicks\n     */\n    addToLeftClickListener : function( listenerFunc )\n    {\n      if ( this.leftClickListeners )\n      {\n        this.leftClickListeners.push( listenerFunc );\n      }\n    },\n\n    addToRightClickListener : function( listenerFunc )\n    {\n      if ( this.rightClickListeners )\n      {\n        this.rightClickListeners.push( listenerFunc );\n      }\n    },\n\n    removeFromLeftClickListener : function( listenerFunc )\n    {\n      if ( this.leftClickListeners )\n      {\n        this.leftClickListeners.remove( listenerFunc );\n      }\n    },\n\n    removeFromRightClickListener : function( listenerFunc )\n    {\n      if ( this.rightClickListeners )\n      {\n        this.rightClickListeners.remove( listenerFunc );\n      }\n    },\n\n    removeAllLeftClickListeners : function()\n    {\n      this.leftClickListeners = [];\n    },\n\n    removeAllRightClickListeners : function()\n    {\n      this.rightClickListeners = [];\n    },\n\n    removeFromLeft : function( id )\n    {\n      if ( this.leftSelectBox )\n      {\n        var leftItems = this.leftSelectBox.immediateDescendants();\n        var toRemoveElement = leftItems.find( function( item )\n        {\n          return !item.selected && item.value == id;\n        } );\n        if ( toRemoveElement )\n        {\n          Element.remove( toRemoveElement );\n          this.setHiddenValues();\n        }\n      }\n    },\n\n    addToLeft : function( id, value, sortString )\n    {\n      if ( this.leftSelectBox )\n      {\n        var leftItems = this.leftSelectBox.immediateDescendants();\n        var returnItem = leftItems.find( function( item )\n        {\n          return item.value == id;\n        } );\n        var exists = returnItem ? true : false;\n        if ( !exists )\n        {\n          this.rawAddToLeft( id, value, sortString );\n          this.setHiddenValues();\n        }\n      }\n    },\n\n    rawAddToLeft : function( id, value, sortString )\n    {\n      var item = document.createElement( "option" );\n      item.value = id;\n      item.innerHTML = value;\n      item.setAttribute( \'sortString\', sortString );\n      this.leftSelectBox.appendChild( item );\n    },\n\n    removeFromRight : function( id )\n    {\n      if ( this.rightSelectBox )\n      {\n        var rightItems = this.rightSelectBox.immediateDescendants();\n        var toRemoveElement = rightItems.find( function( item )\n        {\n          return !item.selected && item.value == id;\n        } );\n        if ( toRemoveElement )\n        {\n          Element.remove( toRemoveElement );\n          this.setHiddenValues();\n        }\n      }\n    },\n\n    addToRight : function( id, value, sortString )\n    {\n      if ( this.rightSelectBox )\n      {\n        var rightItems = this.rightSelectBox.immediateDescendants();\n        var returnItem = rightItems.find( function( item )\n        {\n          return item.value == id;\n        } );\n        var exists = returnItem ? true : false;\n        if ( !exists )\n        {\n          var item = document.createElement( "option" );\n          item.value = id;\n          item.innerHTML = value;\n          item.setAttribute( \'sortString\', sortString );\n          this.rightSelectBox.appendChild( item );\n          this.setHiddenValues();\n        }\n      }\n    },\n\n    resetRightBox : function()\n    {\n      if ( this.rightSelectBox )\n      {\n        var rightItems = this.rightSelectBox.immediateDescendants();\n        rightItems.invoke( "remove" );\n        this.setHiddenValues();\n      }\n    },\n\n    resetLeftBox : function()\n    {\n      if ( this.leftSelectBox )\n      {\n        var leftItems = this.leftSelectBox.immediateDescendants();\n        leftItems.invoke( "remove" );\n        this.setHiddenValues();\n      }\n    },\n\n    getAllLeftAvailableElements : function()\n    {\n      if ( this.leftSelectBox )\n      {\n        return this.leftSelectBox.immediateDescendants();\n      }\n      else\n      {\n        return [];\n      }\n    },\n\n    getAllRightElements : function()\n    {\n      if ( this.rightSelectBox )\n      {\n        var rightItems = this.rightSelectBox.immediateDescendants();\n        return rightItems;\n      }\n      else\n      {\n        return [];\n      }\n    },\n\n    onMoveLeftClick : function( event )\n    {\n\n      var rightItems = this.rightSelectBox.immediateDescendants();\n      var selectedItems = rightItems.findAll( function( item )\n      {\n        return item.selected;\n      } );\n      var leftItems = this.leftSelectBox.immediateDescendants();\n      if ( !selectedItems || selectedItems.length === 0 )\n      {\n        alert( page.bundle.getString( "admin.manageuserlists.selectionwarning" ) );\n        return;\n      }\n      selectedItems.invoke( "remove" );\n      selectedItems.each( function( item )\n      {\n        leftItems.push( item );\n      } );\n      leftItems = leftItems.sortBy( function( option )\n      {\n        return option.getAttribute( "sortString" );\n      } );\n      leftItems.each( function( item )\n      {\n        this.leftSelectBox.appendChild( item );\n      }.bind( this ) );\n      this.setHiddenValues();\n      if ( this.leftClickListeners )\n      {\n        this.leftClickListeners.each( function( listenerFunc )\n        {\n          listenerFunc.apply( this, selectedItems );\n        }.bind( this ) );\n\n      }\n\n    },\n\n    onMoveRightClick : function( event )\n    {\n\n      var leftItems = this.leftSelectBox.immediateDescendants();\n      var selectedItems = leftItems.findAll( function( item )\n      {\n        return item.selected;\n      } );\n      var rightItems = this.rightSelectBox.immediateDescendants();\n      if ( !selectedItems || selectedItems.length === 0 )\n      {\n        alert( page.bundle.getString( "admin.manageuserlists.selectionwarning" ) );\n        return;\n      }\n      selectedItems.invoke( "remove" );\n      selectedItems.each( function( item )\n      {\n        rightItems.push( item );\n      } );\n      rightItems = rightItems.sortBy( function( option )\n      {\n        return option.getAttribute( "sortString" );\n      } );\n      rightItems.each( function( item )\n      {\n        this.rightSelectBox.appendChild( item );\n      }.bind( this ) );\n      this.setHiddenValues();\n      if ( this.rightClickListeners )\n      {\n        this.rightClickListeners.each( function( listenerFunc )\n        {\n          listenerFunc.apply( this, selectedItems );\n        }.bind( this ) );\n      }\n    },\n\n    setHiddenValues : function()\n    {\n\n      var leftString;\n      var rightString;\n      var temp = "";\n\n      // Populate select box values comma separated into leftString,rightString.\n      if ( this.leftSelectBox )\n      {\n        this.leftSelectBox.immediateDescendants().each( function( option )\n        {\n          leftString = option.value;\n          temp += leftString + ",";\n        } );\n        temp = temp.substring( 0, temp.length - 1 );\n        temp = temp.replace( /^\\s*|\\s*$/g, "" );\n        this.leftValues.value = temp;\n        temp = "";\n      }\n      if ( this.rightSelectBox )\n      {\n        this.rightSelectBox.immediateDescendants().each( function( option )\n        {\n          rightString = option.value;\n          temp += rightString + ",";\n        } );\n        temp = temp.substring( 0, temp.length - 1 );\n        temp = temp.replace( /^\\s*|\\s*$/g, "" );\n        this.rightValues.value = temp;\n        temp = "";\n      }\n    },\n\n    onSelectAllClick : function( event, isLeft )\n    {\n      if ( isLeft )\n      {\n        this.leftSelectBox.immediateDescendants().each( function( option )\n        {\n          option.selected = true;\n        } );\n      }\n      else\n      {\n        this.rightSelectBox.immediateDescendants().each( function( option )\n        {\n          option.selected = true;\n        } );\n      }\n      Event.stop( event );\n    },\n\n    onInvertSelection : function( event, isLeft )\n    {\n      if ( isLeft )\n      {\n        this.leftSelectBox.immediateDescendants().each( function( option )\n        {\n          option.selected = !option.selected;\n        } );\n      }\n      else\n      {\n        this.rightSelectBox.immediateDescendants().each( function( option )\n        {\n          option.selected = !option.selected;\n        } );\n      }\n    }\n};\n\n/**\n * A dynamic picker list\n */\nwidget.PickerList = Class.create();\nwidget.PickerList.prototype =\n{\n    /**\n     * Creates a new picker list\n     *\n     * @param id id of the picker list table\n     * @param cellGenerators an array of functions to be called to generate the HTML for the cells for a new row in the\n     *          table.\n     * @param columnAlignments an array of the alignments of the columns\n     * @param columnStyles optional styles to applied to columns\n     * @param reorderable whether the table is to be reorderable\n     * @param reorderingUrl url that reordering changes will be persisted to (can be null)\n     * @param contextParameters parameters that are passed along with the reordering action.\n     */\n    initialize : function( id, cellGenerators, columnAlignments, columnStyles, reorderable, reorderingUrl,\n                           contextParameters )\n    {\n      this.table = $( id );\n      this.reorderable = reorderable;\n      if ( this.table )\n      {\n        this.tableBody = $( this.table.getElementsByTagName( \'tbody\' )[ 0 ] );\n        if ( reorderable )\n        {\n          this.dragDrop = new dragdrop.ListReordering( this.tableBody, this.table.id + \'_reorderControls\', false, \'tr\',\n                                                       \'dndHandle\', \'span\', reorderingUrl, contextParameters,\n                                                       new Date().getTime(), null );\n        }\n      }\n      this.cellGenerators = cellGenerators;\n      this.columnAlignments = columnAlignments;\n      this.columnStyles = columnStyles;\n    },\n\n    /**\n     * This function takes any number of arguments. They will be passed directly to the generator functions. If this\n     * list is reorderable, the first two arguments must be: - id of the item added. - name of the item added.\n     */\n    addRow : function()\n    {\n      var generatorArgs = arguments;\n      var row = $( document.createElement( "tr" ) );\n      if ( this.reorderable )\n      {\n        dragdrop.ListReordering.addDivs(); // Temporarily add the accessible controls to the dom\n        var id = arguments[ 0 ];\n        var name = arguments[ 1 ];\n        // Set the row id so that the drag and drop code can identify the row\n        row.id = this.table.id + \'_row:\' + id;\n        // Add the reordering handle.\n        var cell = document.createElement( "td" );\n        cell.className = \'smallCell dndHandle\';\n        cell.valign = \'top\';\n        cell.innerHTML = \'<span class="reorder"><span><img src="\' + getCdnURL( "/images/ci/icons/generic_updown.gif" ) + \'" alt="" /></span></span>\';\n        row.appendChild( cell );\n        // Add the item to the accessible controls.\n        var accessibleSelect = $( this.table.id + "_reorderControlsSelect" );\n        accessibleSelect.options[ accessibleSelect.length ] = new Option( name, id );\n        dragdrop.ListReordering.removeDivs(); // Remove the accessible controls from the dom again.\n      }\n      this.cellGenerators.each( function( generator, index )\n      {\n        var alignment = this.columnAlignments[ index ];\n        var cell = $( document.createElement( "td" ) );\n        cell.setAttribute( "align", alignment );\n        var columnStyle = this.columnStyles[ index ];\n        if ( \'\' != columnStyle )\n        {\n          cell.addClassName( columnStyle );\n        }\n        cell.innerHTML = generator.apply( window, generatorArgs );\n        row.appendChild( cell );\n      }.bind( this ) );\n      if ( generatorArgs[ 0 ] && generatorArgs[ 0 ].incompatibleFile )\n      {\n        return;\n      }\n      else\n      {\n        this.tableBody.appendChild( row );\n      }\n      if ( this.reorderable )\n      {\n        // Toggle drag and drop so that it picks up the new item.\n        this.dragDrop.disableDragAndDrop();\n        this.dragDrop.enableDragAndDrop();\n        this.dragDrop.calculateItemOrder();\n      }\n      return row;\n    },\n    /**\n     * Removes the row with the specified id or index\n     *\n     * @param idOrIndex - if the argument is a string - it is taken as the id of one of the rows in the table - if the\n     *          argument is a number - the row at the specified index will be removed.\n     */\n    removeRow : function( idOrIndex )\n    {\n      var rowToRemove = null;\n      if ( Object.isString( idOrIndex ) )\n      {\n        rowToRemove = $( this.table.id + "_row:" + idOrIndex );\n      }\n      else\n      {\n        rowToRemove = this.tableBody.childElements()[ idOrIndex ];\n      }\n      if ( rowToRemove )\n      {\n        // Remove the row from the accessible repositioning controls if applicable\n        if ( this.reorderable )\n        {\n          dragdrop.ListReordering.addDivs(); // Temporarily add the accessible controls to the dom\n          var idToCheck = rowToRemove.id.split( \':\' )[ 1 ];\n          var accessibleSelect = $( this.table.id + "_reorderControlsSelect" );\n          var options = accessibleSelect.childElements();\n          for ( var i = 0; i < options.length; i++ )\n          {\n            if ( options[ i ].value == idToCheck )\n            {\n              Element.remove( options[ i ] );\n              break;\n            }\n          }\n          dragdrop.ListReordering.removeDivs(); // Remove the accessible controls from the dom again.\n        }\n        Element.remove( rowToRemove );\n        if ( this.reorderable )\n        {\n          this.dragDrop.calculateItemOrder();\n        }\n      }\n    }\n};\nwidget.PickerList.noopGenerator = function()\n{\n  return \'&nbsp;\';\n};\n\n/**\n * File picker\n */\nwidget.FilePicker = Class.create();\nwidget.FilePicker.prototype =\n{\n    /**\n     * Creates a new file picker\n     *\n     * @param pickerList the javascript object representing the picker list (of currently attached files)\n     * @param baseElementName the base name for the file picker elements\n     * @param required whether a file is required to be chosen\n     * @param overrideLocalBehavior whether the CS options to override local behavior should be shown\n     * @param csPickerUrl url to the CS file picker\n     * @param showAddMetadata whether the "submit and add metadata" content system functionality should be enabled.\n     * @param allowMultipleFiles allow attaching multiple CS and local files.  \n     *   Note, local files are picked one at a time using the browser file picker.  Picking multiple local files at the same\n     *   time is not enabled.\n     * @param onAttachFile Optional callback function triggered when a new file is attached\n     * @param allowMultipleLocalFileUpload whether multiple local file upload selection is enabled.  Local multiple files can be picked \n     *   using drag and drop or using the browser file picker by holding down the shift key and making multiple selections.\n     */\n    initialize : function( pickerList, baseElementName, required, overrideLocalBehavior, csPickerUrl, showAddMetadata,\n                           showSpecialAction, allowMultipleFiles, onAttachFile, allowMultipleLocalFileUpload )\n    {\n      this.pickerList = pickerList;\n      this.baseElementName = baseElementName;\n      this.required = required;\n      this.overrideLocalBehavior = overrideLocalBehavior;\n      this.csPickerUrl = csPickerUrl;\n      this.showAddMetadata = showAddMetadata;\n      this.showSpecialAction = showSpecialAction;\n      this.allowMultipleFiles = allowMultipleFiles;\n      this.allowMultipleLocalFileUpload = allowMultipleLocalFileUpload;\n      this.onAttachFile = onAttachFile;\n\n      this.pickCSButton = $( this.baseElementName + \'_csBrowse\' );\n      this.pickLocalButton = $( this.baseElementName + \'_localBrowse\' );\n      this.localFilePicker = $( this.baseElementName + \'_chooseLocalFile\' );\n\n      this.pickURLButton = $( this.baseElementName + \'_urlBrowse\' );\n\n      this.selectedCSFile = $( this.baseElementName + \'_selectedCSFile\' );\n      this.selectedCSFileName = $( this.baseElementName + \'_selectedCSFileName\' );\n      this.selectedCSFilePath = $( this.baseElementName + \'_selectedCSFilePath\' );\n      this.selectedCSFileSize = $( this.baseElementName + \'_selectedCSFileSize\' );\n      if ( this.showAddMetadata )\n      {\n        this.selectedCSFileMetadata = $( this.baseElementName + \'_selectedCSFileMetadata\' );\n        this.selectedCSFileMetadataSync = $( this.baseElementName + \'_selectedCSFileMetadataSync\' );\n        this.selectedCSFileMetadataFormat = $( this.baseElementName + \'_selectedCSFileMetadataFormat\' );\n      }\n\n      // single file selected area\n      this.selectedFileActionsArea = $( this.baseElementName + \'_selectedFileActions\' );\n      this.selectedFileName = $( this.baseElementName + \'_selectedFileName\' );\n      this.selectedFileSource = $( this.baseElementName + \'_selectedFileSource\' );\n      this.selectedFileLinkTitle = $( this.baseElementName + \'_selectedFileLinkTitle\' );\n      this.selectedFileSpecialAction = $( this.baseElementName + \'_selectedFileSpecialAction\' );\n      this.attachFileButton = $( this.baseElementName + \'_attachFileButton\' );\n      this.cancelFileButton = $( this.baseElementName + \'_cancelFileButton\' );\n\n      this.allowCS = this.pickCSButton ? true : false;\n      this.allowLocal = this.pickLocalButton ? true : false;\n      this.allowURL = this.pickURLButton ? true : false;\n      \n      // lookup for new local files (locally generated id -> file)\n      this.localFileLookup = new Array();\n\n      // Wire up events\n      if ( this.overrideLocalBehavior )\n      {\n        this.pickTargetButton = $( this.baseElementName + \'_CSTargetButton\' );\n        this.targetCSLocation = $( this.baseElementName + \'_CSTarget\' );\n        Event.observe( this.pickTargetButton, "click", this.onPickTargetClick.bindAsEventListener( this ) );\n      }\n\n      this.pickMDButton = $( this.baseElementName + \'_CSTargetMetaButton\' );\n      if ( this.pickMDButton )\n      {\n        window.CSMetadataPickerCallBack = this.afterPickMD.bind( this );\n        Event.observe( this.pickMDButton, "click", this.onPickMDClick.bindAsEventListener( this ) );\n      }\n      if ( $( this.baseElementName + \'_permissionPickerButton0\' ) )\n      {\n        Event.observe( $( this.baseElementName + \'_permissionPickerButton0\' ), "click",\n                       widget.FilePicker.openPermPicker\n                           .bindAsEventListener( this, this.csPickerUrl, this.baseElementName + "_permissions0_manual",\n                                                 this.selectedCSFilePath, this.selectedCSFile, widget.FilePicker.permPickerCallback\n                                                     .curry( this.baseElementName,\n                                                             this.baseElementName + \'_csPermFileList0\', 0 ) ) );\n      }\n      if ( this.allowCS )\n      {\n        Event.observe( this.pickCSButton, "click", this.onCSBrowse.bindAsEventListener( this ) );\n        Event.observe( this.selectedCSFile, "change", this.onCSPick.bindAsEventListener( this ) );\n      }\n      if ( this.allowLocal )\n      {\n        this.localFileContainer = this.localFilePicker.up();\n        Event.observe( this.localFilePicker, "change", this.onLocalPick.bindAsEventListener( this ) );\n      }\n      if ( this.allowURL )\n      {\n        this.linkId = $( this.baseElementName + "_urlBrowse" );\n        this.formDivId = $( this.baseElementName + "_addUrlForm" );\n        this.formContainerId = $( this.baseElementName + "_urlContainerDiv" );\n        var flyout = new flyoutform.FlyoutForm(\n        {\n            linkId : this.linkId,\n            formDivId : this.formDivId,\n            inlineFormContainerId : this.formContainerId,\n            customCallbackObject : this,\n            customOnSubmitHandler : this.onURLPick\n        } );\n        this.flyout = flyout;\n      }\n\n      if ( this.cancelFileButton )\n      {\n        Event.observe( this.cancelFileButton, "click", this.onCancelClick.bindAsEventListener( this ) );\n      }\n\n      if (this.allowLocal || this.allowCS)\n      {\n        var filePickerObj = this;\n        doubleSubmit.registerFormSubmitEvents(this.allowLocal ? this.pickLocalButton.form : this.pickCSButton.form, function(event){\n          return filePickerObj.onSubmit(event);\n        });\n      }\n\n      this.listHtmlDiv = $( this.baseElementName + "_listHtmlDiv" );\n\n      if ( this.listHtmlDiv && this.pickerList && this.pickerList.tableBody && ( this.pickerList.tableBody\n          .getElementsBySelector( \'input[type="hidden"]\' ).length > 0 || this.pickerList.tableBody\n          .getElementsBySelector( \'input[type="file"]\' ).length > 0 ) )\n      {\n        this.listHtmlDiv.show();\n      }\n\n      if ( !this.allowMultipleFiles && this.selectedFileSource.value != \'\' )\n      {\n        // A file is already attached, so show the selected files area and\n        // turn off the file choosing button (and metadata button if any).\n        this.selectedFileActionsArea.show();\n        this.togglePickerButtons( false );\n        if ( this.pickMDButton )\n        {\n          this.pickMDButton.hide();\n        }\n      }\n      \n      // setup multiple local file upload if enabled\n      if ( this.allowMultipleLocalFileUpload )\n      { \n        $j( document ).bind( \'drop dragover\', function ( e ) {\n          // prevent default behavior of dropping a file onto the page opening the file\n          // in the current window\n          e.preventDefault();\n        });\n        \n        var dropZoneArea = document.getElementById( \'bbFilePicker_dropzone_\' + this.baseElementName );\n        var that = this;\n        $j( dropZoneArea ).fileupload(\n        {\n          autoUpload: false, /* do not upload after each file selection */\n          drop : function( e, data )\n          {\n            e.dataTransfer = {};\n            e.dataTransfer.files = data.files;\n            that.onLocalPick( e );\n          }\n        } );\n        \n        // setup drop effect\n        $j( document ).bind( \'dragover\', function( e )\n        {\n          var dropZone = $j( dropZoneArea ), timeout = window.dropZoneTimeout;\n          if ( !timeout )\n          { \n            dropZone.addClass( \'in\' );\n          }\n          else\n          {\n            clearTimeout( timeout );\n          }\n          var found = false, node = e.target;\n          do\n          {\n            if ( node === dropZone[ 0 ] )\n            {\n              found = true;\n              break;\n            }\n            node = node.parentNode;\n          } while ( node != null );\n          if ( found )\n          {\n            dropZone.addClass( \'hover\' );\n          }\n          else\n          {\n            dropZone.removeClass( \'hover\' );\n          }\n          window.dropZoneTimeout = setTimeout( function()\n          {\n            window.dropZoneTimeout = null;\n            dropZone.removeClass( \'in hover\' );\n          }, 100 );\n        } );\n      }\n\n      widget.FilePicker.registerFilePicker( this );\n    },\n    \n    getPickedFiles : function( theForm )\n    {\n      var newLocalFileIndex = 0;\n      var newLocalFilesArray = new Array();\n      $j(this.pickerList.tableBody).find( "input[name=\'" + this.baseElementName + "_attachmentType\']" ).each( function( index, item ) \n      { \n        // Add the new local files to the XHR POST\n        if (item.value === \'L\') \n        { \n          var theRow = $j(item).closest( \'tr\' )[0];\n          var localFileId = theRow.dataset.bbLocalFileId;\n          if ( localFileId )\n          {\n            var theFileObject = window[ this.baseElementName + \'_FilePickerObject\'].localFileLookup[ localFileId ];\n            if ( theFileObject ) \n            {\n              // add the new local file to the form\n              // e.g. \'newFile_LocalFile0\'\n              var inputLocalFileName = this.baseElementName + \'_LocalFile\' + newLocalFileIndex;\n              newLocalFilesArray.push( {\'name\': inputLocalFileName, \'file\': theFileObject } ) ;\n              \n              // MSIE workaround:\n              // MSIE 11 HTML 5 FormData only supports append(), but not set().  The latter replaces any pre-existing\n              // form element with the same name, while append does not.\n              // For XHR local file uploads to work, we need to simulate that behavior ourselves by renaming any pre-existing \n              // file input elements to a dummy name to avoid collisions when we add our final list of local file uploads to the FormData.\n              var existingElement = document.getElementsByName( inputLocalFileName );\n              if ( existingElement.length > 0 )\n              {\n                existingElement[0].name=\'anythingButCurrentName\';\n              }\n              ++newLocalFileIndex;\n            }   \n          }             \n        }\n      }.bind( this ) );\n      \n      return newLocalFilesArray;\n    },\n    \n    /**\n     * Creates a FormData object with the values of the specified form and also adds the local files to upload. This\n     * FormData object is returned to the caller to submit via Ajax upload.\n     */\n    preparePickedFilesForSubmit : function( theForm )\n    {\n      var newLocalFilesArray = this.getPickedFiles( theForm );\n      // Add the final list of local files to upload to the FormData\n      var formData = new FormData( theForm );\n      $j( newLocalFilesArray ).each( function( index, fileInfo )\n      {\n        formData.append( fileInfo.name, fileInfo.file );\n      } );  \n      return formData;\n    },\n    \n    /**\n     * Submits the specified form including picked local files.\n     * \n     * Successful form submission responses may include one of the following:\n     *    destinationUrl - redirect to destinationUrl\n     *    htmlOutput - deposit htmlOutput into current document\n     *    JSCallBack - invoke JSCallBack function. JSCallBack may contain \'.\' i.e.: "edit_assignment.afterSubmit"\n     *    errorMap - mapped localized error messages to filenames are added as error InlineConfirmation\n     *    \n     *    If error or unrecognized response occurs, an InlineConfirmation is displayed with errorMsg\n     * \n     */\n    submitFormUsingAjax : function( theForm, errorMsg )\n    { \n      // prevent double submit\n      if ( doubleSubmit && doubleSubmit.handleFormSubmitEvents( null, theForm, null ) === false )\n      {\n        return;\n      }\n      \n      // Ensure all VTBE text is copied over from the VTBE into their respective textareas\n      if ( typeof( finalizeEditors ) == "function" )\n      {\n        finalizeEditors();\n      }\n\n      var filePickerLastInputId = this.baseElementName +"_" + \'filePickerLastInputId\'; \n      if ( !document.getElementById( filePickerLastInputId  ) )\n      {\n        /**\n         * Workaround to avoid corrupted XHR2 request body in MSIE 11.\n         * In MSIE, XHR2 submits fail if the last form element is an unchecked chedkbox. \n         * Add dummy element to bypass this issue. \n         */\n        var input = document.createElement(\'input\');\n        input.setAttribute("id", filePickerLastInputId);\n        input.setAttribute("type", "hidden");                     \n        input.setAttribute("value", \'dummyValue\');\n        input.setAttribute("name", this.baseElementName + \'filePickerLastInput\' )\n        theForm.appendChild(input);\n      }\n            \n      var data = this.preparePickedFilesForSubmit( theForm );\n      var that = this;\n      \n      this.wasCannotPickFolderDialogAlreadyShown = false;\n      $j.ajax(\n      {\n          url : theForm.action,\n          data : data,\n          processData : false,\n          contentType : false,\n          type : \'POST\',\n          success : function( response )\n          {\n            if ( response.destinationUrl )\n            { \n              // Redirect to URL\n              window.location.href = response.destinationUrl;\n            }\n            else if (response.htmlOutput )\n            { \n              // replace window contents with specified HTML\n              document.body.innerHTML = response.htmlOutput;\n              page.globalEvalScripts( response.htmlOutput, false );\n            }\n            else if ( response.JSCallBack )\n            { \n              try\n              {\n                var methods = response.JSCallBack.split(".");\n                var f = window;\n                for (var i = 0; i < methods.length; i++) {\n                    f = f[methods[i]];\n                }\n                f();\n              }\n              catch( err )\n              {\n                new page.InlineConfirmation( "error", err.message, false, true );\n              }\n            }\n            else\n            { \n              if ( doubleSubmit )\n              {\n                doubleSubmit.allowSubmitAgainForForm( theForm );\n              }\n              if ( response.errorMap )\n              { \n                for (var key in response.errorMap) \n                {\n                  new page.InlineConfirmation( "error", key + " " + response.errorMap[key], false, true );\n                }\n              }\n              else\n              {\n                new page.InlineConfirmation( "error", errorMsg, false, true );\n              }\n              if ( response.nonceId && theForm.elements[\'blackboard.platform.security.NonceUtil.nonce\'] )\n              {\n                theForm.elements[\'blackboard.platform.security.NonceUtil.nonce\'].value = response.nonceId;\n              }\n            }\n          },\n          error : function( data )\n          { \n            if ( doubleSubmit )\n            {\n              doubleSubmit.allowSubmitAgainForForm( theForm );\n            }\n            that.alertIfUserAddedFolderUsingSafari();\n            new page.InlineConfirmation( "error", errorMsg, false, true );\n          }\n      } );\n    },\n    \n    // Safari makes it appear as if you can drop a folder but when it throws an error once you try to read from the inputstream.\n    // This function checks for that case here: if it is, show an alert box asking\n    // the user to remove any possible folders.  This quirk only occurs for Safari.  Chrome does support folder drops, and MSIE\n    // an FF ignore folder drops.\n    alertIfUserAddedFolderUsingSafari: function()\n    {\n      var attachmentLookupMap = this.localFileLookup;\n      var hasPossibleFolder = false;\n      var isSafari = this.isSafari();\n      if ( isSafari )\n      {\n        var that = this;\n        // Check whether any of the picked local files could be folders.  Stop looking once we find a folder.\n        for (var key in attachmentLookupMap) {\n          if ( attachmentLookupMap.hasOwnProperty(key) ) \n          {\n            var file = attachmentLookupMap[ key ];\n            reader = new FileReader();\n            reader.onerror = function (event) {\n              if (!that.wasCannotPickFolderDialogAlreadyShown )\n              { \n                // User picked a folder using Safari.  Show an alert and set a flag.\n                that.wasCannotPickFolderDialogAlreadyShown = true;\n                alert( page.bundle.getString( \'filePicker.localPickedFile.error.safari.possibleFolder\' ) );\n              }\n            };\n            // Try reading the first 2 bytes to check whether we can actually read the file.\n            // Note: readAsText is an asynchronous call, so the read operation  run any time during or after this for loop is completed.\n            // As a result, we can\'t do things like break the loop if an error occurs.\n            // To get results of readAsText() we rely on the above onerror function callback.\n            reader.readAsText(file.slice( 0, 2) );\n          }   \n        }                   \n      }\n    },\n    \n    isSafari: function()\n    {\n      return navigator.vendor.indexOf("Apple")==0 && /\\sSafari\\//.test(navigator.userAgent);\n    },\n    \n    /**\n     * For the override local behavior: show the picker to pick the location\n     */\n    onPickTargetClick : function( event )\n    {\n      var remote = popop.launchPicker( \'/webapps/cmsmain/folderpicker/\', \'picker_browse\' );\n      if ( remote )\n      {\n        remote.opener.inputEntryURLToSet = this.targetCSLocation;\n        remote.opener.returnFullURL = false;\n        remote.methodCall = this.onPickMDClick.bind( this );\n      }\n    },\n\n    /**\n     * For the override local behavior: show the picker to pick the metadata\n     */\n    onPickMDClick : function( event )\n    {\n      var location = this.targetCSLocation;\n      var file = this.localFilePicker;\n      if ( file.value == \'\' )\n      {\n        return;\n      }\n      var url = \'/webapps/cmsmain/execute/metadatapicker/manage?action=pick&file=\' + file.value;\n      if ( location && location.value != \'\' )\n      {\n        url += \'location=\' + location.value;\n      }\n\n      popup.launchPicker( url, \'picker_browse\' );\n    },\n\n    /**\n     * For the override local behavior: callback from the metadata picker\n     */\n    afterPickMD : function( metadata, selection, synchronised, format )\n    {\n      $( this.baseElementName + \'_CSTargetmetadata\' ).value = metadata;\n      $( this.baseElementName + \'_CSTargetselection\' ).value = selection;\n      $( this.baseElementName + \'_CSTargetSynchronised\' ).value = synchronised;\n      $( this.baseElementName + \'_CSTargetDisplayFormat\' ).value = format;\n    },\n\n    /**\n     * Show the CS file chooser\n     */\n    onCSBrowse : function( event )\n    {\n      this.csBrowseWindow = null;\n      var windowId = new Date().getTime();\n      var myLightbox = new lightbox.Lightbox(\n      {\n          lightboxId : windowId,\n          dimensions :\n          {\n              w : 1200,\n              h : 675\n          },\n          title : page.bundle.getString( \'lightbox.title\' ),\n          ajax :\n          {\n              url : this.csPickerUrl,\n              loadExternalScripts : true\n          },\n          closeOnBodyClick : false,\n          msgs :\n          {\n            \'close\' : page.bundle.getString( \'lightbox.close\' )\n          }\n      } );\n\n      myLightbox.resourcePickerCustomHandler = this.onCSPick.bind( this );\n\n      if ( !this.allowMultipleFiles )\n      {\n        // only used for single resource picking\n        myLightbox.resourcePickerProperties =\n        {};\n        myLightbox.resourcePickerProperties.inputEntryURLToSet = this.selectedCSFile;\n        myLightbox.resourcePickerProperties.inputFileSizeToSet = this.selectedCSFileSize;\n        myLightbox.resourcePickerProperties.linkName = this.selectedCSFileName;\n        if ( this.selectedCSFilePath )\n        {\n          myLightbox.resourcePickerProperties.filePath = this.selectedCSFilePath;\n        }\n      }\n      myLightbox.open();\n      Event.stop( event );\n      return false;\n    },\n\n    /**\n     * Called after file has been chosen from CS file picker with metadata added.\n     */\n    afterMD : function( metadata, synced, format, fileId )\n    {\n      var metadataString = metadata.join( "#" );\n\n      if ( fileId )\n      {\n        if ( $( this.baseElementName + \'_CSMetadata_\' + fileId ) )\n        {\n          $( this.baseElementName + \'_CSMetadata_\' + fileId ).value = metadataString;\n        }\n        if ( $( this.baseElementName + \'_CSMetadataSync_\' + fileId ) )\n        {\n          $( this.baseElementName + \'_CSMetadataSync_\' + fileId ).value = synced;\n        }\n        if ( $( this.baseElementName + \'_CSMetadataFormat_\' + fileId ) )\n        {\n          $( this.baseElementName + \'_CSMetadataFormat_\' + fileId ).value = format;\n        }\n      }\n      else\n      {\n        if ( this.selectedCSFileMetadata )\n        {\n          this.selectedCSFileMetadata.value = metadataString;\n        }\n        if ( this.selectedCSFileMetadataSync )\n        {\n          this.selectedCSFileMetadataSync.value = synced;\n        }\n        if ( this.selectedCSFileMetadataFormat )\n        {\n          this.selectedCSFileMetadataFormat.value = format;\n        }\n      }\n    },\n\n    /**\n     * Callback called after a file has been chosen from the CS file picker in single file mode - updating selected\n     * files section\n     */\n    onCSPick : function( fileList )\n    {\n      if ( this.listHtmlDiv )\n      {\n        this.listHtmlDiv.show();\n      }\n\n      if ( this.allowMultipleFiles )\n      {\n        // picker was opened in multiple mode but one of the legacy page was hit\n        // create object cell generator is expecting using hidden input\n        if ( typeof ( fileList ) == \'string\' )\n        {\n          var filePath = this.selectedCSFilePath ? this.selectedCSFilePath.value : "";\n          var csFile =\n          {\n              fileName : this.selectedCSFile.value,\n              fullUrlToFile : this.selectedCSFile.value,\n              linkTitle : this.selectedCSFileName.value,\n              filePath : filePath,\n              size : this.selectedCSFileSize.value\n          };\n          this.onCSPickAllowMultiple( [ csFile ] );\n        }\n        else\n        {\n          this.onCSPickAllowMultiple( fileList );\n        }\n      }\n      else\n      {\n        this.csBrowseWindow = null;\n        this.selectedFileSource.value = \'C\';\n        this.selectedFileName.innerHTML = this.selectedCSFileName.value;\n        if ( this.selectedFileLinkTitle )\n        {\n          this.selectedFileLinkTitle.value = this.selectedCSFileName.value;\n        }\n        this.selectedFileActionsArea.show();\n        this.togglePickerButtons( false );\n        if ( this.pickMDButton )\n        {\n          this.pickMDButton.hide();\n        }\n        if ( $( this.baseElementName + \'_csPermissionsLi\' ) )\n        {\n          var fileName = this.selectedCSFileName.value;\n          var ext = fileName.match( /.*\\.(.*)/ );\n          ext = ext ? ext[ 1 ] : \'\';\n\n          // Determine the type of the attached file.\n          if ( ( /html|htm/i ).test( ext ) )\n          {\n            $( this.baseElementName + "_permissionOptionsIndex" ).value = 0;\n            $( this.baseElementName + \'_csPermissionsLi\' ).show();\n          }\n        }\n        if ( this.onAttachFile )\n        {\n          this.onAttachFile( this, false );\n        }\n      }\n    },\n\n    /**\n     * Called after a file is chosen from the local file picker in single file mode - updating selected files section\n     */\n    onLocalPick : function( event )\n    {\n      if ( this.localFilePicker.value != \'\' || event && event.dataTransfer && event.dataTransfer.files && event.dataTransfer.files.length > 0 )\n      {\n        if ( this.allowMultipleLocalFileUpload || this.allowMultipleFiles )\n        {  \n          var pickedLocalFiles = null;\n          if ( event && event.dataTransfer && event.dataTransfer.files && event.dataTransfer.files.length > 0 )\n          { \n            // picked files via drag and drop\n            pickedLocalFiles = event.dataTransfer.files;\n          }\n          else\n          { \n            // picked files via file browser\n            pickedLocalFiles = this.localFilePicker.files;\n          }\n          if ( pickedLocalFiles && pickedLocalFiles.length > 0 )\n          {\n            $A( pickedLocalFiles ).each( function( file, index )\n            { \n              if ( file.size === 0) \n              { \n                // If the file is empty don\'t upload it.\n                // Note: In JQuery returning true in a \'each\' function is like a \'continue\' in a for loop.\n                return true;\n              }\n              \n              // When dropping a folder, make sure we only accept files at the top level directory.  We \n              // do not accept files from subdirectories (e.g. not f1/f2/foo.html).\n              // The following regex counts the number of \'/\' to ensure we do not have more than one.\n              // Note: Directory separaters are always \'/\' for files dropped using the JQuery File Upload API.\n              var isSubDirectoryFile = ( file.relativePath && (file.relativePath.match(/\\//g) || []).length > 1 );\n              if ( isSubDirectoryFile === true )\n              { \n                // continue the loop to go to the next file.\n                // Note: In JQuery returning true in a \'each\' function is like a \'continue\' in a for loop.\n                return true;\n              }\n              var pickedLocalFile =\n              {\n                  localFilePicker :\n                  {\n                    value : file.name\n                  },\n                  baseElementName : this.baseElementName,\n                  getFileName : this.getFileName,\n                  shouldManagePermission : this.shouldManagePermission,\n                  file: file\n              };\n              // The file passed our criteria so we can now show the listHtmlDiv\n              if ( this.listHtmlDiv && !this.listHtmlDiv.visible() )\n              {\n                this.listHtmlDiv.show();\n              }\n\n              // Replace local file input if this is the last local picked file\n              var isReplaceLocalInput = ( ( index + 1 ) === pickedLocalFiles.length ); \n              this.onLocalPickAllowMultiple( event, pickedLocalFile, isReplaceLocalInput );\n            }.bind( this ) );\n          }\n        }\n        else\n        { \n          if ( this.listHtmlDiv )\n          {\n            this.listHtmlDiv.show();\n          }\n          var localFileName = this.getFileName( this.localFilePicker.value );\n          this.selectedFileName.innerHTML = localFileName;\n          if ( this.selectedFileLinkTitle )\n          {\n            this.selectedFileLinkTitle.value = localFileName;\n          }\n          this.selectedFileSource.value = \'L\';\n          this.selectedFileActionsArea.show();\n          this.togglePickerButtons( false );\n          if ( this.pickMDButton )\n          {\n            this.pickMDButton.show();\n          }\n          if ( this.onAttachFile )\n          {\n            this.onAttachFile( this, true );\n          }\n          if ( this.selectedFileLinkTitle )\n          {\n            this.selectedFileLinkTitle.focus();\n          }\n        }\n      }\n    },\n\n    /**\n     * Callback called after files have been chosen from the CS file picker in multiple files mode - updating table\n     */\n    onCSPickAllowMultiple : function( fileList )\n    {\n      this.csBrowseWindow = null;\n      \n      var removeExisting = document.getElementById(\'sourceFile_successDIV\');\n      if (removeExisting != null)\n      {\n        removeExisting.parentNode.removeChild(removeExisting);\n      }\n      \n      var msgContainer = new Element( \'div\' )\n      .update( \'<span class="hideoff" tabindex="-1" role="alert" id="sourceFile_success">\' + page.bundle.getString( \'content.media.fileSuccess\' ) + \'</span>\' );\n      \n      msgContainer.id=\'sourceFile_successDIV\';\n      \n      var div = document.getElementById(\'newFile_listHtmlDiv\');\n      if(div != null)\n      {\n        var parentDiv = div.parentNode;\n        parentDiv.insertBefore(msgContainer, div);\n      }\n      \n      var successMsg = document.getElementById(\'sourceFile_successDIV\');\n      if( null !== successMsg )\n      {\n        successMsg.setAttribute(\'aria-live\', \'assertive\');\n        successMsg.setAttribute(\'aria-atomic\', \'true\');\n      }\n      \n      fileList.each( function( selectedFile )\n      {\n        selectedFile.baseElementName = this.baseElementName;\n        selectedFile.showAddMetadata = this.showAddMetadata;\n        selectedFile.csPickerUrl = this.csPickerUrl;\n        var rowCheck = document.getElementById(selectedFile.baseElementName + "_rowid_" + selectedFile.xythosId);\n        if (rowCheck)\n          return;\n\n        var row = this.pickerList.addRow( selectedFile, false );\n\n        // Wire a listener that will show the embed options when the embed action is chosen (if configured to)\n        this.registerEmbedOptionsListener( widget.FilePicker.cellGenerators.fileActionEmbedOptions_index - 1 );\n\n        if ( this.onAttachFile )\n        {\n          this.onAttachFile( this, false, row );\n        }\n      }.bind( this ) );\n    },\n\n    /**\n     * Called after a file is chosen from the local file picker in multiple files mode - updating table\n     */\n    onLocalPickAllowMultiple : function( event, theFilePickerObject, replaceLocalFileInput )\n    {\n      var row = this.pickerList.addRow( theFilePickerObject, true );\n      if ( row === null )\n      {\n        return;\n      }\n      \n      if ( this.allowMultipleLocalFileUpload )\n      {\n        var attachmentTypeCell = $j(row).find( "input[name=\'" + this.baseElementName + "_attachmentType\']" );\n        var uniqueId = this.generateUniqueId();\n        row.dataset.bbLocalFileId = uniqueId;\n        this.localFileLookup[ uniqueId ] = theFilePickerObject.file;\n      }\n\n      // Wire a listener that will show the embed options when the embed action is chosen (if configured to)\n      this.registerEmbedOptionsListener( widget.FilePicker.cellGenerators.fileActionEmbedOptions_index - 1 );\n      if (replaceLocalFileInput === false ) \n      {\n        return;\n      }\n\n      var cell = $( row.getElementsByTagName( \'td\' )[ 0 ] );\n      var title = this.localFilePicker.title;\n\n      Element.remove( this.localFilePicker );\n      this.localFilePicker.removeClassName( "hiddenInput" );\n      this.localFilePicker.setStyle(\n      {\n          position : "absolute",\n          top : \'-10000px\'\n      } );\n      this.localFilePicker.disabled = false;\n      cell.appendChild( this.localFilePicker );\n\n      // Set up the names of the local file fields\n      this.pickerList.tableBody.getElementsBySelector( \'input[type="file"]\' ).each( function( item, index )\n      {\n        item.name = this.baseElementName + \'_LocalFile\' + index;\n      }.bind( this ) );\n\n      // Create and insert a new local file picker for more local file attaching\n      var newPicker = new Element( \'input\',\n      {\n          title : title,\n          type : \'file\',\n          multiple: this.allowMultipleLocalFileUpload ? true : false\n      } );\n      newPicker.addClassName( \'hiddenInput\' );\n      this.localFileContainer.insertBefore( newPicker, this.localFileContainer.firstChild );\n      Event.observe( newPicker, "change", this.onLocalPick.bindAsEventListener( this ) );\n\n      if ( this.onAttachFile )\n      {\n        this.onAttachFile( this, true, row );\n      }\n      this.localFilePicker = newPicker;\n    },\n    \n    generateUniqueId : function()\n    {\n      return \'_\' + Math.random().toString( 36 ).substr( 2, 9 );\n    },\n\n    /**\n     * If a) Special Actions are enabled, and b) the embed options are configure to show up: - Wires up an on change\n     * even on the special action select box that shows the embed options when the embed action is chosen.\n     */\n    registerEmbedOptionsListener : function( index )\n    {\n      if ( this.showSpecialAction )\n      {\n        var specialAction = $( this.baseElementName + \'_specialAction\' + index );\n        var embedOptions = $( this.baseElementName + \'_embedOptions\' + index );\n        if ( embedOptions )\n        {\n          specialAction.observe( \'change\', function( event )\n          {\n            if ( "EMBED" == specialAction.options[ specialAction.selectedIndex ].value )\n            {\n              embedOptions.show();\n            }\n            else\n            {\n              embedOptions.hide();\n            }\n          } );\n        }\n      }\n    },\n\n    /**\n     * Called after a url is chosen from the local file picker in multiple files mode - updating table\n     */\n    onURLPick : function( widget )\n    {\n      var selectedURL = document.getElementById( widget.baseElementName + \'_newUrlName\' );\n      if (selectedURL.value.blank()) // TODO: More exhaustive URL validation?\n      {\n        alert(page.bundle.getString(\'filePicker.validate.invalid.url\'));\n        return false;\n      }\n\n      if ( widget.listHtmlDiv )\n      {\n        widget.listHtmlDiv.show();\n      }\n\n\n      if ( widget.allowMultipleFiles )\n      {\n        var urlFile =\n        {\n            fileName : selectedURL.value,\n            fullUrlToFile : selectedURL.value,\n            linkTitle : selectedURL.value\n        };\n\n        widget.onCSPickAllowMultiple( [ urlFile ] );\n      }\n      else\n      {\n        widget.selectedFileSource.value = \'C\';\n        widget.selectedFileName.innerHTML = selectedURL.value;\n        if ( widget.selectedFileLinkTitle )\n        {\n          widget.selectedFileLinkTitle.value = selectedURL.value;\n        }\n        widget.selectedFileActionsArea.show();\n        widget.togglePickerButtons( false );\n        if ( widget.pickMDButton )\n        {\n          widget.pickMDButton.hide();\n        }\n        if ( widget.onAttachFile )\n        {\n          widget.onAttachFile( widget, false );\n        }\n      }\n\n      // Purge entry\n      widget.flyout.close();\n      selectedURL.value = \'\';\n      return true;\n    },\n\n    /**\n     * Called when the "Do not attach file" button is clicked\n     */\n    onCancelClick : function( event )\n    {\n      this.selectedFileActionsArea.hide();\n      this.clearSelectedFileInfo();\n      this.togglePickerButtons( true );\n      if ( event )\n      {\n        Event.stop( event );\n      }\n    },\n\n    /**\n     * Toggles the enabled state of the Local/CS picker buttons to the specified state\n     */\n    togglePickerButtons : function( enabled )\n    {\n      if ( this.allowLocal )\n      {\n        this.pickLocalButton.disabled = !enabled;\n        if ( enabled )\n        {\n          this.pickLocalButton.className = \'browse visibleInput\';\n          this.localFilePicker.position = \'relative\';\n          this.localFilePicker.style.top = \'\';\n        }\n        else\n        {\n          this.pickLocalButton.className = \'disabled\';\n          this.localFilePicker.position = \'absolute\';\n          this.localFilePicker.style.top = \'-10000px\';\n        }\n        if ( this.allowMultiple )\n        {\n          this.localFilePicker.disabled = !enabled;\n        }\n      }\n      if ( this.allowCS )\n      {\n        this.pickCSButton.disabled = !enabled;\n        if ( enabled )\n        {\n          this.pickCSButton.className = \'browse visibleInput\';\n        }\n        else\n        {\n          this.pickCSButton.className = \'disabled\';\n        }\n      }\n      if ( this.allowURL )\n      {\n        this.pickURLButton.disabled = !enabled;\n        if ( enabled )\n        {\n          this.pickURLButton.className = \'browse visibleInput\';\n        }\n        else\n        {\n          this.pickURLButton.className = \'disabled\';\n        }\n      }\n    },\n\n    /**\n     * Clears the info associated to the current attached file (if the user cancelled, or chose to attach another file )\n     */\n    clearSelectedFileInfo : function()\n    {\n      var isLocal = this.selectedFileSource.value == \'L\';\n      this.selectedFileName.innerHTML = "";\n      this.selectedFileSource.value = "";\n      if ( this.selectedFileLinkTitle )\n      {\n        this.selectedFileLinkTitle.value = "";\n      }\n      if ( this.pickMDButton )\n      {\n        $( this.baseElementName + \'_CSTargetmetadata\' ).value = "";\n        $( this.baseElementName + \'_CSTargetselection\' ).value = "";\n        $( this.baseElementName + \'_CSTargetSynchronised\' ).value = "";\n        $( this.baseElementName + \'_CSTargetDisplayFormat\' ).value = "";\n      }\n      if ( $( this.baseElementName + "_permissionOptionsIndex" ) )\n      {\n        $( this.baseElementName + \'_permissionOptionsIndex\' ).value = -1;\n        $( this.baseElementName + \'_permissions0_all\' ).checked = true;\n      }\n      if ( this.selectedFileSpecialAction )\n      {\n        this.selectedFileSpecialAction.selectedIndex = 0;\n      }\n      if ( isLocal )\n      {\n        var title = "";\n        if ( !this.allowMultipleFiles )\n        {\n          title = this.localFilePicker.title;\n          Element.remove( this.localFilePicker );\n        }\n        this.localFilePicker = $( document.createElement( "input" ) );\n        if ( !this.allowMultipleFiles )\n        {\n          this.localFilePicker.name = this.baseElementName + \'_LocalFile0\';\n          this.localFilePicker.tabIndex=\'-1\';\n          this.localFilePicker.id=this.baseElementName + \'_chooseLocalFile\';\n        }\n        this.localFilePicker.title = title;\n        this.localFilePicker.type = "file";\n        this.localFilePicker.addClassName( "hiddenInput" );\n        this.localFileContainer.insertBefore( this.localFilePicker, this.localFileContainer.firstChild );\n        Event.observe( this.localFilePicker, "change", this.onLocalPick.bindAsEventListener( this ) );\n      }\n      else\n      {\n        this.selectedCSFile.value = "";\n        this.selectedCSFileName.value = "";\n        if ( this.selectedFilePath )\n        {\n          this.selectedFilePath = "";\n        }\n        this.selectedCSFileSize.value = "";\n        if ( this.showAddMetadata )\n        {\n          this.selectedCSFileMetadata.value = "";\n          this.selectedCSFileMetadataSync.value = "";\n          this.selectedCSFileMetadataFormat.value = "";\n        }\n      }\n    },\n\n    /**\n     * Gets the file name based on the full file path.\n     */\n    getFileName : function( fullPath )\n    {\n      var result = fullPath;\n      var lastIndexOfBackslash = fullPath.lastIndexOf( \'\\\\\' );\n      var lastIndexOfSlash = fullPath.lastIndexOf( \'/\' );\n      if ( lastIndexOfBackslash > lastIndexOfSlash )\n      {\n        result = fullPath.substring( lastIndexOfBackslash + 1, fullPath.length );\n      }\n      else if ( lastIndexOfSlash > lastIndexOfBackslash )\n      {\n        result = fullPath.substring( lastIndexOfSlash + 1, fullPath.length );\n      }\n      return result;\n    },\n\n    isFileNameValid : function( fileName )\n    {\n      //KEEP IN SYNC WITH FileSystemUtil.isValidEntryName\n      if (!fileName || /[\\/\\\\:?*"<>|]/.test( fileName ) )\n      {\n        return false;\n      }\n      return true;\n    },\n\n    setRequired : function( required )\n    {\n      this.required = required;\n    },\n\n    /**\n     * Validates the form when it is submitted.\n     */\n    onSubmit : function( event )\n    {\n      // Validate the form if necessary\n      if ( this.required )\n      {\n        if ( this.allowMultipleFiles )\n        {\n          if ( this.pickerList.tableBody.immediateDescendants().length === 0 )\n          {\n            alert( page.bundle.getString( "filePicker.validate.atLeastOne" ) );\n            if ( event )\n            {\n              Event.stop( event );\n            }\n            return false;\n          }\n        }\n        else\n        {\n          if ( ( this.selectedCSFile && this.selectedCSFile.value == \'\' ) && ( this.localFilePicker && this.localFilePicker.value == \'\' ) )\n          {\n            alert( page.bundle.getString( "filePicker.validate.one" ) );\n            if ( event )\n            {\n              Event.stop( event );\n            }\n            return false;\n          }\n          else if ( this.localFilePicker && this.localFilePicker.value != \'\' )\n          {\n            var fileName = this.getFileName( this.localFilePicker.value );\n            if( !this.isFileNameValid( fileName ) )\n            {\n              //KEEP IN SYNC WITH FileSystemUtil.isValidEntryName\n              var invalidChars = "/ \\\\ : ? * \\" < > |";\n              var alertMsg = page.bundle.getString( "filePicker.validate.invalid.filename", fileName, invalidChars );\n              alert( alertMsg );\n              if ( event )\n              {\n                Event.stop( event );\n              }\n              return false;\n            }\n          }\n        }\n      }\n      return true;\n    }\n\n};\n\n// Creates hidden input items for selected files/folders if giving access to additional files/folder\n// when attaching an HTML file\nwidget.FilePicker.permPickerCallback = function( baseElementName, permFileList, index, itemList )\n{\n  if ( itemList && itemList.length > 0 )\n  {\n    var i;\n    var permFileListElem = $( permFileList );\n    var hiddenInputs = "";\n\n    if ( !permFileListElem )\n    {\n      return;\n    }\n\n    hiddenInputs += \'<input type="hidden" name="\' + baseElementName + \'_permittedFiles\' + index + \'" value="\' + itemList[ 0 ].fileName;\n    for ( i = 1; i < itemList.length; i++ )\n    {\n      hiddenInputs += \':\' + itemList[ i ].fileName;\n    }\n    hiddenInputs += \'">\';\n    permFileListElem.innerHTML = hiddenInputs;\n  }\n};\n\n/**\n * Toggles the "mark for removal" status of an item in the currently attached files table. Should be called from an\n * onclick attribute on the toggle link in the table.\n */\nwidget.FilePicker.toggleForRemove = function( event, removeLink )\n{\n  var e = event || window.event;\n  removeLink = $( removeLink );\n  var tableRow = removeLink.up( "tr" );\n  var hiddenField = removeLink.up( "td" ).down( \'input[type="hidden"]\' );\n\n  tableRow.toggleClassName( "removeCell" );\n  if ( hiddenField.disabled )\n  {\n    hiddenField.disabled = false;\n    removeLink.innerHTML = page.bundle.getString( "filePicker.unmarkForRemove" );\n  }\n  else\n  {\n    hiddenField.disabled = true;\n    removeLink.innerHTML = page.bundle.getString( "filePicker.markForRemove" );\n  }\n  Event.stop( e );\n};\n\nwidget.FilePicker.togglePickerButton = function( pickerButton, enabled )\n{\n  if ( enabled )\n  {\n    $( pickerButton ).setAttribute( "href", "#" );\n    $( pickerButton ).removeClassName( "disabled" );\n  }\n  else\n  {\n    $( pickerButton ).removeAttribute( "href" );\n    $( pickerButton ).addClassName( "disabled" );\n  }\n};\n\n/**\n * Removes the specified pending attachment. Should be called from an onclick handler on a link in the currently\n * attached files table\n */\nwidget.FilePicker.removePendingAttachment = function( event, removeLink, baseElementName )\n{\n  var e = event || window.event;\n  if ( confirm( page.bundle.getString( "filePicker.doNotAttach.confirm" ) ) )\n  {\n    widget.FilePicker.removePendingAttachmentInternal( removeLink, baseElementName );\n  }\n  Event.stop( e );\n};\n\n/**\n * Removes the specified pending attachment without asking for confirmation.\n */\nwidget.FilePicker.removePendingAttachmentInternal = function( removeLink, baseElementName )\n{\n  removeLink = $( removeLink );\n  var row = removeLink.up( "tr" );\n  var tbody = row.up( "tbody" );\n  \n  // Remove the local file object from localFileLookup\n  if ( row.dataset && row.dataset.bbLocalFileId )\n  {\n    var localFileId = row.dataset.bbLocalFileId;\n    if ( localFileId )\n    {\n      delete window[ baseElementName + \'_FilePickerObject\' ].localFileLookup[ localFileId ];\n    }\n  }\n\n  // Remove the pending row\n  Element.remove( row );\n\n  // Re-index the local file inputs.\n  tbody.getElementsBySelector( \'input[type="file"]\' ).each( function( item, index )\n  {\n    item.name = baseElementName + \'_LocalFile\' + index;\n  } );\n\n  // Hide the whole attached files table if there are no more attached files.\n  var rowTotal = tbody.getElementsByTagName( \'tr\' ).length;\n  if ( rowTotal === 0 )\n  {\n    var listHtmlDiv = $( baseElementName + "_listHtmlDiv" );\n    if ( listHtmlDiv )\n    {\n      var msg = document.getElementById(\'sourceFile_successDIV\');\n      if(msg != null)\n      {\n        msg.parentNode.removeChild(msg);\n      }\n        \n      listHtmlDiv.hide();\n    }\n  }\n};\n\nwidget.FilePicker.getPermPickerUrl = function( csPickerUrl, path, pathElement )\n{\n  // reuse current file picker\'s url as fall back plan\n  var baseUrl = csPickerUrl.split( "?" )[ 0 ];\n  var queryParams = csPickerUrl.toQueryParams();\n  queryParams.multi = \'true\';\n  if (queryParams.cmd == \'pickFile\')\n    queryParams.cmd = \'pickFileAndFolder\';\n\n  if (!path && pathElement)\n  {\n    path = pathElement.value;\n  }\n  queryParams.start_path=path;\n\n  return baseUrl + "?" + $H( queryParams ).toQueryString();\n};\n\nwidget.FilePicker.openPermPicker = function( event, csPickerUrl, pid, path, pathElement, callback )\n{\n  if ( !( pid && $( pid ) && $( pid ).type == \'radio\' && $( pid ).checked ) )\n  {\n    return false;\n  }\n\n  var permPickerUrl = permPickerUrl = widget.FilePicker.getPermPickerUrl( csPickerUrl, path, pathElement );\n\n  var windowId = "picker" + new Date().getTime();\n  var myLightbox = new lightbox.Lightbox(\n  {\n      lightboxId : windowId,\n      dimensions :\n      {\n          w : 1200,\n          h : 675\n      },\n      title : page.bundle.getString( \'lightbox.title\' ),\n      ajax :\n      {\n          url : permPickerUrl,\n          loadExternalScripts : true\n      },\n      closeOnBodyClick : false,\n      msgs :\n      {\n        \'close\' : page.bundle.getString( \'lightbox.close\' )\n      }\n  } );\n\n  if ( callback )\n  {\n    myLightbox.resourcePickerCustomHandler = callback;\n  }\n\n  if ( !this.allowMultipleFiles )\n  {\n    // only used for single resource picking\n    myLightbox.resourcePickerProperties =\n    {};\n    myLightbox.resourcePickerProperties.inputEntryURLToSet = this.selectedCSFile;\n    myLightbox.resourcePickerProperties.inputFileSizeToSet = this.selectedCSFileSize;\n    myLightbox.resourcePickerProperties.linkName = this.selectedCSFileName;\n    if ( this.selectedCSFilePath )\n    {\n      myLightbox.resourcePickerProperties.filePath = this.selectedCSFilePath;\n    }\n  }\n  myLightbox.open();\n  Event.stop( event );\n  return false;\n};\n\n/**\n * A registry of defined file pickers and methods to access this registry\n */\nwidget.FilePicker.filePickers =\n{};\nwidget.FilePicker.registerFilePicker = function( filePicker )\n{\n  widget.FilePicker.filePickers[ filePicker.baseElementName ] = filePicker;\n};\nwidget.FilePicker.unRegisterFilePicker = function( filePicker )\n{\n  delete widget.FilePicker.filePickers[ filePicker.baseElementName ];\n};\nwidget.FilePicker.getFilePicker = function( baseElementName )\n{\n  return widget.FilePicker.filePickers[ baseElementName ];\n};\n\n/**\n * Cell generators for the current attached files table\n */\nwidget.FilePicker.cellGenerators =\n{\n    fileName : function( filePicker, isLocal )\n    {\n      var result = \'<input id="\' + filePicker.baseElementName + \'_rowid_\' + filePicker.xythosId + \'" type="hidden" name="\' + filePicker.baseElementName + \'_attachmentType" value="\' + ( isLocal ? \'L\' : \'C\' ) + \'">\';\n      result += \'<input type="hidden" name="\' + filePicker.baseElementName + \'_fileId" value="new">\';\n      result += \'<input type="hidden" name="\' + filePicker.baseElementName + \'_artifactFileId" value="\' + filePicker.artifactFileId + \'">\';\n      result += \'<input type="hidden" name="\' + filePicker.baseElementName + \'_artifactType" value="\' + filePicker.artifactType + \'">\';\n      result += \'<input type="hidden" name="\' + filePicker.baseElementName + \'_artifactTypeResourceKey" value="\' + filePicker.artifactTypeResourceKey + \'">\';\n      if ( isLocal )\n      {\n        result += \'<span class="fileName"><img src="\' + getCdnURL( "/images/ci/ng/cal_year_event.gif" ) + \'" alt="\' + page.bundle\n            .getString( \'common.file\' ) + \'"> \' + filePicker.getFileName( filePicker.localFilePicker.value ) + \'</span>\';\n      }\n      else\n      {\n        result += \'<span class="fileName"><img src="\' + getCdnURL( "/images/ci/ng/cal_year_event.gif" ) + \'" alt="\' + page.bundle\n            .getString( \'common.file\' ) + \'"> \' + filePicker.linkTitle + \'</span>\';\n        result += \'<input type="hidden" name="\' + filePicker.baseElementName + \'_CSFile" value="\' + filePicker.fileName + \'">\';\n        result += \'<input type="hidden" name="\' + filePicker.baseElementName + \'_CSFileUrl" value="\' + filePicker.fullUrlToFile + \'">\';\n        if ( filePicker.showAddMetadata )\n        {\n          result += \'<input type="hidden" name="\' + filePicker.baseElementName + \'_CSMetadata" id="\' + filePicker.baseElementName + \'_CSMetadata_\' + filePicker.xythosId + \'" value="">\';\n          result += \'<input type="hidden" name="\' + filePicker.baseElementName + \'_CSMetadataSync" id="\' + filePicker.baseElementName + \'_CSMetadataSync_\' + filePicker.xythosId + \'" value="">\';\n          result += \'<input type="hidden" name="\' + filePicker.baseElementName + \'_CSMetadataFormat" id="\' + filePicker.baseElementName + \'_CSMetadataFormat_\' + filePicker.xythosId + \'" value="">\';\n        }\n      }\n      return result;\n    },\n    fileType : function( filePicker, isLocal )\n    {\n      var result = null;\n      if ( isLocal )\n      {\n        result = page.bundle.getString( "filePicker.fileType.attachment" );\n      }\n      else\n      {\n        result = page.bundle.getString( "filePicker.fileType.content" );\n      }\n      return result;\n    },\n    linkTitle : function( filePicker, isLocal )\n    {\n      var linkTitle = "";\n      if ( isLocal )\n      {\n        linkTitle = filePicker.getFileName( filePicker.localFilePicker.value );\n      }\n      else\n      {\n        if ( filePicker.linkTitle )\n        {\n          linkTitle = filePicker.linkTitle;\n        }\n      }\n      // \'linkTitle\' is used as an HTML attribute value and is enclosed by double quotes.\n      // When the value contains double quotes it needs to be converted to its HTML entity representation to avoid\n      // malformed HTML ( an example of malformed HTML is -> value="".docx" ).\n      linkTitle = linkTitle.replace( /"/g, \'&quot;\' );\n      return \'<input type="text" name="\' + filePicker.baseElementName + \'_linkTitle" value="\' + linkTitle +\n             \'" title="\' + page.bundle.getString( "filePicker.nameOfLink" ) + " " + linkTitle + \'">\';\n    },\n    size : function( filePicker, isLocal )\n    {\n      if ( !isLocal && filePicker.size )\n      {\n        return \'<input type="hidden" name="\' + filePicker.baseElementName + \'_size" value="\' + filePicker.size + \'"> \' + filePicker.size;\n      }\n      else\n      {\n        return "";\n      }\n    },\n    fileAction : function( filePicker, isLocal )\n    {\n      return widget.FilePicker.cellGenerators.fileActionEmbedOptions( filePicker, isLocal, true );\n    },\n    fileActionEmbedOptions_index : 0, // used to uniquely identify embed options form elements on the page.\n    fileActionEmbedOptions : function( filePicker, isLocal, suppressOptions )\n    {\n      var index = widget.FilePicker.cellGenerators.fileActionEmbedOptions_index++;\n      var baseName = filePicker.baseElementName;\n\n      var fileName = isLocal ? filePicker.getFileName( filePicker.localFilePicker.value ) : filePicker.linkTitle;\n      var ext = fileName.match( /.*\\.(.*)/ );\n      ext = ext ? ext[ 1 ] : \'\';\n\n      // Determine the type of the attached file.\n      var isType =\n      {\n          image : ( /gif|jpeg|png|tif|bmp|jpg/i ).test( ext ),\n          videoQt : ( /qt|mov|moov|movie/i ).test( ext ),\n          videoOther : ( /avi|mpg|mpeg|wmv|asf|wma|mpe/i ).test( ext ),\n          real : ( /ra|ram|rm/i ).test( ext ),\n          flash : ( /swa|swf/i ).test( ext ),\n          audio : ( /aif|aiff|au|mp3|wav/i ).test( ext ),\n          html : ( /html|htm/i ).test( ext )\n      };\n\n      var isMedia = isType.image || isType.videoQt || isType.videoOther || isType.flash || isType.audio;\n\n      var result = \'\';\n      if ( isMedia )\n      {\n        result += \'<select id="\' + baseName + \'_specialAction\' + index + \'" name="\' + baseName + \'_specialAction"\';\n        result += \' title="\' + page.bundle.getString( "filePicker.specialAction.for" ) + " " + fileName + \'">\';\n        result += \'<option value="LINK">\' + page.bundle.getString( "filePicker.specialAction.link" ) + \'</option>\';\n        result += \'<option value="EMBED">\' + page.bundle.getString( "filePicker.specialAction.embed" ) + \'</option>\';\n        result += \'</select>\';\n\n        // Render the embed options (if not suppressed)\n        if ( !suppressOptions )\n        {\n          result += \'<ul style="display: none;" class="nestedList smallControls liveArea liveArea-slim" id="\' + baseName + \'_embedOptions\' + index + \'">\';\n\n          // Alignment\n          var fid = baseName + \'align\' + index;\n          result += \'<li><div class="label">\' + page.bundle.getString( \'wysiwyg.insert_picture.alignment\' ) + \'</div><div class="field" style="white-space:nowrap;">\' + \'<fieldset role="radiogroup"><legend><span class="hideoff">\' + page.bundle\n              .getString( \'wysiwyg.insert_picture.alignment\' ) + \'</span></legend>\' + \'<input type="radio" id="\' + fid + \'_l" name="\' + fid + \'" value="Left" checked> <label for="\' + fid + \'_l">\' + page.bundle\n              .getString( \'wysiwyg.insert_picture.alignment.left\' ) + \'</label>\' + \'<input type="radio" id="\' + fid + \'_c" name="\' + fid + \'" value="Center"> <label for="\' + fid + \'_c">\' + page.bundle\n              .getString( \'wysiwyg.insert_picture.alignment.center\' ) + \'</label>\' + \'<input type="radio" id="\' + fid + \'_r" name="\' + fid + \'" value="Right"> <label for="\' + fid + \'_r">\' + page.bundle\n              .getString( \'wysiwyg.insert_picture.alignment.right\' ) + \'</label></fieldset></div></li>\';\n\n          // Placement\n          fid = baseName + \'placement\' + index;\n          result += \'<li><div class="label">\' + page.bundle.getString( \'wysiwyg.insert_picture.placement\' ) + \'</div><div class="field" style="white-space:nowrap;">\' + \'<fieldset role="radiogroup"><legend><span class="hideoff">\' + page.bundle\n              .getString( \'wysiwyg.insert_picture.placement\' ) + \'</span></legend>\' + \'<input type="radio" id="\' + fid + \'_a" name="\' + fid + \'" value="Above"> <label for="\' + fid + \'_a">\' + page.bundle\n              .getString( \'wysiwyg.insert_picture.placement.above\' ) + \'</label>\' + \'<input type="radio" id="\' + fid + \'_b" name="\' + fid + \'" value="Below" checked> <label for="\' + fid + \'_b">\' + page.bundle\n              .getString( \'wysiwyg.insert_picture.placement.below\' ) + \'</label></fieldset></div></li>\';\n\n          // Dimensions\n          if ( !isType.audio )\n          {\n            fid = baseName + \'width\' + index;\n            result += \'<li><div class="label"><label for="\' + fid + \'">\' + page.bundle\n                .getString( \'wysiwyg.insert_picture.width\' ) + \'</label></div><div class="field"><input class="width" type="text" name="\' + fid + \'" id="\' + fid + \'" size="4" value=""></div></li>\';\n\n            fid = baseName + \'height\' + index;\n            result += \'<li><div class="label"><label for="\' + fid + \'">\' + page.bundle\n                .getString( \'wysiwyg.insert_picture.height\' ) + \'</label></div><div class="field"><input class="height" type="text" name="\' + fid + \'" id="\' + fid + \'" size="4" value=""></div></li>\';\n          }\n\n          // Autoplay\n          if ( !isType.image )\n          {\n            fid = baseName + \'autostart\' + index;\n            result += \'<li><div class="label">\' + page.bundle.getString( \'wysiwyg.insert_picture.autostart\' ) + \'</div><div class="field" style="white-space:nowrap;">\' + \'<fieldset role="radiogroup"><legend><span class="hideoff">\' + page.bundle\n                .getString( \'wysiwyg.insert_picture.autostart\' ) + \'</span></legend>\' + \'<input type="radio" id="\' + fid + \'_y" name="\' + fid + \'" value="true"> <label for="\' + fid + \'_y">\' + page.bundle\n                .getString( \'wysiwyg.insert_picture.yes\' ) + \'</label>\' + \'<input type="radio" id="\' + fid + \'_n" name="\' + fid + \'" value="false" checked> <label for="\' + fid + \'_n">\' + page.bundle\n                .getString( \'wysiwyg.insert_picture.no\' ) + \'</label></fieldset></div></li>\';\n          }\n\n          // Loop\n          if ( !isType.image && !isType.real )\n          {\n            fid = baseName + \'loop\' + index;\n            result += \'<li><div class="label">\' + page.bundle.getString( \'wysiwyg.insert_picture.loop\' ) + \'</div><div class="field" style="white-space:nowrap;">\' + \'<fieldset role="radiogroup"><legend><span class="hideoff">\' + page.bundle\n                .getString( \'wysiwyg.insert_picture.loop\' ) + \'</span></legend>\' + \'<input type="radio" id="\' + fid + \'_y" name="\' + fid + \'" value="true"> <label for="\' + fid + \'_y">\' + page.bundle\n                .getString( \'wysiwyg.insert_picture.yes\' ) + \'</label>\' + \'<input type="radio" id="\' + baseName + \'loop\' + index + \'_n" name="\' + fid + \'" value="false" checked> <label for="\' + fid + \'_n">\' + page.bundle\n                .getString( \'wysiwyg.insert_picture.no\' ) + \'</label></fieldset></div></li>\';\n          }\n\n          // Control (radio)\n          if ( isType.videoQt || isType.real )\n          {\n            fid = baseName + \'controls\' + index;\n            result += \'<li><div class="label">\' + page.bundle.getString( \'wysiwyg.insert_picture.controls\' ) + \'</div><div class="field" style="white-space:nowrap;">\' + \'<fieldset role="radiogroup"><legend><span class="hideoff">\' + page.bundle\n                .getString( \'wysiwyg.insert_picture.controls\' ) + \'</span></legend>\' + \'<input type="radio" id="\' + fid + \'_y" name="\' + fid + \'" value="Full" checked> <label for="\' + fid + \'_y">\' + page.bundle\n                .getString( \'wysiwyg.insert_picture.yes\' ) + \'</label>\' + \'<input type="radio" id="\' + fid + \'_n" name="\' + fid + \'" value="None"> <label for="\' + fid + \'_n">\' + page.bundle\n                .getString( \'wysiwyg.insert_picture.no\' ) + \'</label></fieldset></div></li>\';\n          }\n\n          // Controls (drop down)\n          if ( isType.videoOther || isType.audio )\n          {\n            fid = baseName + \'controls\' + index;\n            result += \'<li><div class="label"><label for="\' + fid + \'">\' + page.bundle\n                .getString( \'wysiwyg.insert_picture.controls\' ) + \'</label></div><div class="field"><select id="\' + fid + \'" name="\' + fid + \'" class="controls">\' + \'<option value="None">\' + page.bundle\n                .getString( \'wysiwyg.insert_picture.controls_none\' ) + \'</option>\' + \'<option value="Mini">\' + page.bundle\n                .getString( \'wysiwyg.insert_picture.controls_mini\' ) + \'</option>\' + \'<option value="Full" selected>\' + page.bundle\n                .getString( \'wysiwyg.insert_picture.controls_full\' ) + \'</option>\' + \'</select></div></li>\';\n          }\n\n          // Quality\n          if ( isType.flash )\n          {\n            fid = baseName + \'quality\' + index;\n            result += \'<li><div class="label"><label for="\' + fid + \'">\' + page.bundle\n                .getString( \'wysiwyg.insert_picture.set_quality\' ) + \'</label></div><div class="field"><select id="\' + fid + \'" name="\' + fid + \'" class="quality">\' + \'<option value="Low">\' + page.bundle\n                .getString( \'wysiwyg.insert_picture.quality_low\' ) + \'</option>\' + \'<option value="Medium">\' + page.bundle\n                .getString( \'wysiwyg.insert_picture.quality_med\' ) + \'</option>\' + \'<option value="High">\' + page.bundle\n                .getString( \'wysiwyg.insert_picture.quality_high\' ) + \'</option>\' + \'<option value="Best" selected>\' + page.bundle\n                .getString( \'wysiwyg.insert_picture.quality_best\' ) + \'</option>\' + \'</select></div></li>\';\n          }\n\n          if ( isType.image )\n          {\n            // URL\n            fid = baseName + \'url\' + index;\n            result += \'<li><div class="label"><label for="\' + fid + \'">\' + page.bundle\n                .getString( \'wysiwyg.insert_picture.url\' ) + \'</label></div><div class="field"><input type="text" name="\' + fid + \'" id="\' + fid + \'" size="25">\' + \'</div></li>\';\n\n            // New Window\n            fid = baseName + \'newwin\' + index;\n            result += \'<li><div class="label">\' + page.bundle.getString( \'wysiwyg.insert_picture.new_window\' ) + \'</div><div class="field" style="white-space:nowrap;">\' + \'<fieldset role="radiogroup"><legend><span class="hideoff">\' + page.bundle\n                .getString( \'wysiwyg.insert_picture.new_window\' ) + \'</span></legend>\' + \'<input type="radio" id="\' + fid + \'_y" name="\' + fid + \'" value="true" checked> <label for="\' + fid + \'_y">\' + page.bundle\n                .getString( \'wysiwyg.insert_picture.yes\' ) + \'</label>\' + \'<input type="radio" id="\' + fid + \'_n" name="\' + fid + \'" value="false"> <label for="\' + fid + \'_n">\' + page.bundle\n                .getString( \'wysiwyg.insert_picture.no\' ) + \'</label>\' + \'</fieldset></div></li>\';\n\n            // Border\n            fid = baseName + \'border\' + index;\n            result += \'<li><div class="label"><label for="\' + fid + \'">\' + page.bundle\n                .getString( \'wysiwyg.insert_picture.border\' ) + \'</label></div><div class="field"><select id="\' + fid + \'" name="\' + fid + \'" class="border">\' + \'<option value="0" selected>\' + page.bundle\n                .getString( \'wysiwyg.insert_picture.none\' ) + \'</option>\' + \'<option value="1>1</option><option value="2">2</option><option value="3">3</option>\' + \'<option value="4">4</option></select></div></li>\';\n          }\n\n          // Alt text\n          fid = baseName + \'alttext\' + index;\n          result += \'<li><div class="label"><label for="\' + fid + \'">\' + page.bundle\n              .getString( \'wysiwyg.insert_picture.alt_text\' ) + \'</label></div><div class="field"><input type="text" name="\' + fid + \'" id="\' + fid + \'" size="25" value=""></div><span class="fieldHelp clearfloats">\' + page.bundle\n              .getString( \'wysiwyg.insert_picture.alt_text.instructions\' ) + \'</span></li>\';\n\n          result += \'</ul>\';\n        }\n      }\n      else\n      {\n        result += \'<input type="hidden" name="\' + filePicker.baseElementName + \'_specialAction" value="LINK">\';\n        result += page.bundle.getString( "filePicker.specialAction.link" );\n      }\n      // The index is used to find the correct request parameters on the backend.\n      result += \'<input type="hidden" name="\' + filePicker.baseElementName + \'_specialActionIndex" value="\' + ( isMedia && !suppressOptions ? index : -1 ) + \'">\';\n\n      if ( filePicker.shouldManagePermission && !isLocal )\n      {\n        // permission management options\n        var permissionCsPickerUrl = filePicker.csPickerUrl;\n        if ( permissionCsPickerUrl.indexOf( \'multipicker=true\' ) != -1 )\n        {\n          var xythosId = filePicker.fileName.sub( \'/xid-\', \'\' ).strip();\n          if ( xythosId )\n          {\n            permissionCsPickerUrl = permissionCsPickerUrl + \'&preselectedItemId=\' + xythosId;\n          }\n        }\n\n        result += \'<ul id="\' + filePicker.baseElementName + \'_imgSpecOptions" class="nestedList smallControls liveArea liveArea-slim">\';\n        result += \'<li>\';\n        var pid = baseName + "_permissions" + index;\n        var pickerButtonId = baseName + "_permissionPickerButton" + index;\n        var permFileListName = baseName + \'_csPermFileList\' + index;\n        result += \'<input type="radio" name="\' + pid + \'" value="A" id="\' + pid + \'_all" checked="checked" onChange="widget.FilePicker.togglePickerButton(\\\'\' + pickerButtonId + \'\\\', false)" />\' + page.bundle\n            .getString( "fm.permission.grant.all" ) + \'<br/>\';\n        result += \'<input type="radio" name="\' + pid + \'" value="O" id="\' + pid + \'_this" onChange="widget.FilePicker.togglePickerButton(\\\'\' + pickerButtonId + \'\\\', false)" />\' + page.bundle\n            .getString( "fm.permission.grant.this" ) + \'<br/>\';\n        result += \'<input type="radio" name="\' + pid + \'" value="S" id="\' + pid + \'_manual" onChange="widget.FilePicker.togglePickerButton(\\\'\' + pickerButtonId + \'\\\', true)" />\' + page.bundle\n            .getString( "fm.permission.grant.manual" );\n        result += \'<a id="\' + pickerButtonId + \'" class="button-4 disabled" style="margin:0 3px" onclick="widget.FilePicker.openPermPicker( event, \\\'\' + permissionCsPickerUrl + \'\\\', \\\'\' + pid + \'_manual\\\',\\\'\' + filePicker.filePath + \'\\\',\\\'\' + filePicker.fileName + \'\\\', widget.FilePicker.permPickerCallback.curry( \\\'\' + baseName + \'\\\', \\\'\' + permFileListName + \'\\\', \' + index + \' ) );">\' + page.bundle\n            .getString( "filePicker.browse" ) + \'</a>\';\n        result += \'</li>\';\n        result += \'</ul>\';\n        result += \'<div id="\' + permFileListName + \'" style="display: none;"></div>\';\n      }\n      result += \'<input type="hidden" name="\' + baseName + \'_permissionOptionsIndex" value="\' + ( isType.html && !isLocal ? index : -1 ) + \'">\';\n\n      return result;\n    },\n    remove : function( filePicker, isLocal )\n    {\n      var result = \'<a href="#" onclick="widget.FilePicker.removePendingAttachment(event, this, \';\n      result += "\'" + filePicker.baseElementName + "\'";\n      result += \');">\' + page.bundle.getString( "filePicker.doNotAttach" ) + \'</a>\';\n\n      return result;\n    },\n\n  // attach CS file alignment to course item\n  align : function(filePicker, isLocal) {\n    var alignOptionsName = "csAlignedResources";\n    var html = \'<label  for="csAlignedResources" style="white-space:nowrap">\'\n        + \'<input type="checkbox" id="\'\n        + alignOptionsName\n        + \'"\'\n        + \' name="\'\n        + alignOptionsName\n        + \'"\'\n        + \' value="\'\n        + filePicker.filePath\n        + \'"\'\n        + \'/>\'\n        + \' \'\n        + page.bundle.getString(\'wysiwyg.insert_picture.csalign\')\n        + \'</label>\';\n    return html;\n  }\n};\n\nwidget.InlineSingleCSFilePicker = Class.create();\nwidget.InlineSingleCSFilePicker.prototype =\n{\n    initialize : function( baseElementName, csPickerUrl, showAddMetadata, showSpecialAction )\n    {\n      this.baseElementName = baseElementName;\n      this.csPickerUrl = csPickerUrl;\n      this.showAddMetadata = showAddMetadata;\n      this.showSpecialAction = showSpecialAction;\n      this.browseButton = $( baseElementName + \'_csBrowse\' );\n      this.fileEntry = $( baseElementName + \'_CSFile\' );\n      this.fileId = $( baseElementName + \'_fileId\' );\n      if ( this.showAddMetadata )\n      {\n        this.selectedCSFileMetadata = $( this.baseElementName + \'_CSMetadata\' );\n        this.selectedCSFileMetadataSync = $( this.baseElementName + \'_CSMetadataSync\' );\n        this.selectedCSFileMetadataFormat = $( this.baseElementName + \'_CSFileMetadataFormat\' );\n      }\n\n      Event.observe( this.browseButton, \'click\', this.onCSBrowse.bindAsEventListener( this ) );\n    },\n\n    /**\n     * Show the CS file chooser\n     */\n    onCSBrowse : function( event )\n    {\n      this.csBrowseWindow = null;\n      var windowId = "picker" + new Date().getTime();\n      var myLightbox = new lightbox.Lightbox(\n      {\n          lightboxId : windowId,\n          dimensions :\n          {\n              w : 1200,\n              h : 675\n          },\n          title : page.bundle.getString( \'lightbox.title\' ),\n          ajax :\n          {\n              url : this.csPickerUrl,\n              loadExternalScripts : true\n          },\n          closeOnBodyClick : false,\n          msgs :\n          {\n            \'close\' : page.bundle.getString( \'lightbox.close\' )\n          }\n      } );\n\n      if ( !this.allowMultipleFiles )\n      {\n        // only used for single resource picking\n        myLightbox.resourcePickerProperties =\n        {};\n        myLightbox.resourcePickerProperties.inputEntryURLToSet = this.fileEntry;\n        myLightbox.resourcePickerProperties.returnFullURL = false;\n        myLightbox.resourcePickerProperties.linkName = this.fileId;\n      }\n      myLightbox.open();\n      Event.stop( event );\n      return false;\n    },\n\n    afterMD : function( metadata, synced, format )\n    {\n      var metadataString = metadata.join( "#" );\n      this.selectedCSFileMetadata.value = metadataString;\n      this.selectedCSFileMetadataSync.value = synced;\n      this.selectedCSFileMetadataFormat.value = format;\n    }\n};\n\n/**\n * Inline single local file picker - $baseElementName_attachmentType - \'AL\' or \'L\' or \'\' - $baseElementName_localBrowse -\n * $baseElementName_fileId\n */\nwidget.InlineSingleLocalFilePicker = Class.create();\nwidget.InlineSingleLocalFilePicker.prototype =\n{\n    initialize : function( baseElementName, currentAttachedFile, required, showSpecialAction )\n    {\n      this.baseElementName = baseElementName;\n      this.fileInput = $( baseElementName + \'_chooseLocalFile\' );\n      this.pickLocalButton = $( baseElementName + \'_localBrowse\' );\n      this.fileInputWrapper = $( this.fileInput.parentNode );\n      this.attachmentType = $( baseElementName + \'_attachmentType\' );\n      this.fullFileName = $( baseElementName + \'_fileId\' );\n      this.attachmentNameSpan = $( baseElementName + \'_attachmentName\' );\n      this.removeLink = $( baseElementName + \'_removeLink\' );\n      this.inputArea = $( baseElementName + \'_inputArea\' );\n      this.attachedFileArea = $( baseElementName + \'_attachedFileArea\' );\n      this.required = required;\n      this.showSpecialAction = showSpecialAction;\n      // Wire up events\n      Event.observe( this.fileInput, "change", this.onAfterChooseFile.bindAsEventListener( this ) );\n      Event.observe( this.removeLink, "click", this.onRemoveClick.bindAsEventListener( this ) );\n      var inlineSingleLocalFilePickerObj = this;\n      doubleSubmit.registerFormSubmitEvents(this.fileInput.form, function(event){\n        return inlineSingleLocalFilePickerObj.onSubmit(event);\n      });\n\n      // Set up initial values\n      if ( currentAttachedFile )\n      {\n        this.setDefaultCurrentAttachedFile( currentAttachedFile );\n        this.setTabIndexesHideAriaBrowseInput();\n      }\n      else\n      {\n        //hide the remove link element\n        this.setTabIndexesHideAriaRemoveInput();\n      }\n      widget.InlineSingleLocalFilePicker.pickerMap[ baseElementName ] = this;\n    },\n    //set browse button to be un-tabble and not read by screen reader\n    //if there is a file already shown (i.e. the remove button is showing)\n    setTabIndexesHideAriaBrowseInput : function()\n    {\n      if( this.fileInput != null && this.pickLocalButton != null )\n      {\n        this.fileInput.setAttribute( "aria-hidden", true );\n        this.fileInput.setAttribute( "tabindex", \'-1\' );\n        this.fileInput.setAttribute( "style", \'display: none; visibility: hidden\' );\n        this.pickLocalButton.setAttribute( "aria-hidden", true );\n        this.pickLocalButton.setAttribute( "tabindex", \'-1\' );\n        this.pickLocalButton.setAttribute( "style", \'display: none; visibility: hidden\' );\n      }\n    },\n    //set remove button to be un-tabble and not read by screen reader\n    setTabIndexesHideAriaRemoveInput : function()\n    {\n      if( this.removeLink != null )\n      {\n        this.removeLink.setAttribute( "aria-hidden", true );\n        this.removeLink.setAttribute( "tabindex", -1 );\n        this.removeLink.setAttribute( "style", \'display: none; visibility: hidden\' );\n      }\n    },\n    setCurrentAttachedFile : function( file )\n    {\n      this.clearFileInput();\n      if ( file )\n      {\n        this.attachmentType.value = \'AL\';\n        this.attachmentNameSpan.innerHTML = \'<a href="\' + file + \'" target="_blank">\' + this.getFileName( file ) + \'</a>\';\n        if ( this.removeHiddenField )\n        {\n          Element.remove( this.removeHiddenField );\n          this.removeHiddenField = null;\n        }\n        widget.ShowUnsavedChanges.changeHiddenValue( this.fullFileName, file );\n        this.inputArea.setStyle(\n        {\n            position : "absolute",\n            top : \'-10000px\'\n        } );\n        this.attachedFileArea.setStyle(\n        {\n            position : "static",\n            top : \'\'\n        } );\n      }\n      else\n      {\n        this.attachmentNameSpan.innerHTML = \'\';\n        this.attachmentType.value = \'\';\n        widget.ShowUnsavedChanges.changeHiddenValue( this.fullFileName, \'\' );\n        this.inputArea.setStyle(\n        {\n            position : "static",\n            top : \'\'\n        } );\n        this.attachedFileArea.setStyle(\n        {\n            position : "absolute",\n            top : \'-10000px\'\n        } );\n      }\n    },\n    setDefaultCurrentAttachedFile : function( file )\n    {\n      this.clearFileInput();\n      if ( file )\n      {\n        this.attachmentType.value = \'AL\';\n        this.attachmentType._defaultValue = \'AL\';\n        this.attachmentNameSpan.innerHTML = \'<a href="\' + file + \'" target="_blank">\' + this.getFileName( file ) + \'</a>\';\n        if ( this.removeHiddenField )\n        {\n          Element.remove( this.removeHiddenField );\n          this.removeHiddenField = null;\n        }\n        this.fullFileName.value = file;\n        this.fullFileName._defaultValue = file;\n        this.inputArea.setStyle(\n        {\n            position : "absolute",\n            top : \'-10000px\'\n        } );\n        this.attachedFileArea.setStyle(\n        {\n            position : "static",\n            top : \'\'\n        } );\n      }\n      else\n      {\n        this.attachmentNameSpan.innerHTML = \'\';\n        this.attachmentType.value = \'\';\n        this.fullFileName.value = \'\';\n        this.inputArea.setStyle(\n        {\n            position : "static",\n            top : \'\'\n        } );\n        this.attachedFileArea.setStyle(\n        {\n            position : "absolute",\n            top : \'-10000px\'\n        } );\n      }\n    },\n    onAfterChooseFile : function( event )\n    {\n      this.attachmentNameSpan.innerHTML = this.getFileName( this.fileInput.value, true );\n      this.attachmentType.value = \'L\';\n      if ( this.removeHiddenField )\n      {\n        Element.remove( this.removeHiddenField );\n        this.removeHiddenField = null;\n      }\n      widget.ShowUnsavedChanges.changeHiddenValue( this.fullFileName, this.fileInput.value );\n      this.inputArea.setStyle(\n      {\n          position : "absolute",\n          top : \'-10000px\'\n      } );\n      this.attachedFileArea.setStyle(\n      {\n          position : "static",\n          top : \'\'\n      } );\n      \n      this.setTabIndexesHideAriaBrowseInput();\n      \n      //show the remove button\n      this.removeLink.setAttribute( "aria-hidden", false );\n      this.removeLink.removeAttribute( "tabindex" );\n      this.removeLink.removeAttribute( "style" );\n      \n      Event.stop( event );\n    },\n    onRemoveClick : function( event )\n    {\n      this.clearFileInput();\n      if ( this.attachmentType.value == \'AL\' )\n      {\n        this.removeHiddenField = document.createElement( \'input\' );\n        this.removeHiddenField.type = \'hidden\';\n        this.removeHiddenField.name = this.baseElementName + \'_remove\';\n        this.removeHiddenField.id = this.baseElementName + \'_remove\';\n        this.removeHiddenField.value = this.fullFileName.value;\n        this.attachedFileArea.insertBefore( this.removeHiddenField, this.attachedFileArea.firstChild );\n        widget.ShowUnsavedChanges.changeHiddenValue( this.fullFileName, this.fullFileName.value );\n      }\n      else\n      {\n        this.attachmentType.value = \'\';\n        widget.ShowUnsavedChanges.changeHiddenValue( this.fullFileName, \'\' );\n      }\n      this.attachmentNameSpan.innerHTML = \'\';\n\n      //hide the remove link element\n      this.setTabIndexesHideAriaRemoveInput();\n      \n      //show the browse button (remove the display none / visibility hidden)\n      this.fileInput.removeAttribute( "style" );\n      this.pickLocalButton.removeAttribute( "style" );\n      \n      this.inputArea.setStyle(\n      {\n          position : "static",\n          top : \'\'\n      } );\n      this.attachedFileArea.setStyle(\n      {\n          position : "absolute",\n          top : \'-10000px\'\n      } );\n      Event.stop( event );\n    },\n    clearFileInput : function()\n    {\n      var title = this.fileInput.title;\n      Element.remove( this.fileInput );\n      this.fileInput = $( document.createElement( "input" ) );\n      this.fileInput.title = title;\n      this.fileInput.type = "file";\n      this.fileInput.addClassName( "hiddenInput" );\n      this.fileInput.name = this.baseElementName + \'_LocalFile0\';\n      this.fileInput.id = this.baseElementName + \'_chooseLocalFile\';\n      this.fileInput._defaultValue = \'\';\n      this.fileInputWrapper.insertBefore( this.fileInput, this.fileInputWrapper.firstChild );\n      Event.observe( this.fileInput, "change", this.onAfterChooseFile.bindAsEventListener( this ) );\n    },\n    /**\n     * Gets the file name based on the full file path.\n     *\n     * @param fullPath Fully-qualified path of file\n     * @param isDecodedName (optional) Indicates that the filename has already been URL decoded\n     */\n    getFileName : function( fullPath, isDecodedName )\n    {\n      var result = fullPath;\n      var lastIndexOfBackslash = fullPath.lastIndexOf( \'\\\\\' );\n      var lastIndexOfSlash = fullPath.lastIndexOf( \'/\' );\n      if ( lastIndexOfBackslash > lastIndexOfSlash )\n      {\n        result = fullPath.substring( lastIndexOfBackslash + 1, fullPath.length );\n      }\n      else if ( lastIndexOfSlash > lastIndexOfBackslash )\n      {\n        result = fullPath.substring( lastIndexOfSlash + 1, fullPath.length );\n      }\n      return isDecodedName ? result : decodeURI( result );\n    },\n    /**\n     * Validates the form when it is submitted.\n     */\n    onSubmit : function( event )\n    {\n      // Validate the form if necessary\n      if ( event && this.required )\n      {\n        if ( this.fullFileName.value == \'\' )\n        {\n          alert( page.bundle.getString( "filePicker.validate.one" ) );\n          if( event )\n          {\n            Event.stop( event );\n          }\n          return false;\n        }\n      }\n      return true;\n    }\n};\nwidget.InlineSingleLocalFilePicker.pickerMap =\n{};\n\n/**\n * Read Only File picker\n */\nwidget.ReadOnlyFilePicker = Class.create();\nwidget.ReadOnlyFilePicker.prototype =\n{\n  /**\n   * Creates a new file picker\n   *\n   * @param baseElementName the base name for the file picker elements\n   */\n  initialize : function( baseElementName )\n  {\n    this.baseElementName = baseElementName;\n    this.listHtmlDiv = $( this.baseElementName + "_listHtmlDiv" );\n\n    if ( this.listHtmlDiv )\n    {\n      this.listHtmlDiv.show();\n    }\n    widget.ReadOnlyFilePicker.pickerMap[ baseElementName ] = this;\n  }\n};\nwidget.ReadOnlyFilePicker.pickerMap =\n{};\n\nwidget.UserRoleSelect = Class.create();\nwidget.UserRoleSelect.prototype =\n{\n    initialize : function( userSelectRoleDivStr, moveMsgJS, noRoleMsgJs )\n    {\n      this.sourceValueName = "_left_values";\n      this.secondaryValueName = "_right_values";\n      this.primaryValueName = "_primary_value";\n\n      this.userSelectRoleDiv = $( userSelectRoleDivStr );\n      if ( this.userSelectRoleDiv )\n      {\n        var selects = this.userSelectRoleDiv.getElementsByTagName( \'select\' );\n        var inputs = this.userSelectRoleDiv.getElementsByTagName( \'input\' );\n        var links = this.userSelectRoleDiv.getElementsByTagName( \'a\' );\n        this.source = $( selects[ 0 ] );\n        this.primary = $( inputs[ 3 ] );\n        this.secondary = $( selects[ 1 ] );\n\n        this.leftValues = $( inputs[ 0 ] );\n        this.rightValues = $( inputs[ 1 ] );\n        this.primaryValue = $( inputs[ 2 ] );\n\n        this.toPrimaryMove = $( links[ 0 ] );\n        this.toSecondaryMove = $( links[ 1 ] );\n        this.toSourceMove = $( links[ 2 ] );\n\n        this.left_arrow = getCdnURL( "/images/ci/ng/cm_arrow_left.gif" );\n        this.right_arrow = getCdnURL( "/images/ci/ng/cm_arrow_right.gif" );\n        this.left_disabled_arrow = getCdnURL( "/images/ci/ng/cm_arrow_left_disabled.gif" );\n        this.right_disabled_arrow = getCdnURL( "/images/ci/ng/cm_arrow_right_disabled.gif" );\n\n        Event.observe( this.toSourceMove, "click", this.switchUserRoleColumns.bindAsEventListener( this, false,\n                                                                                                   moveMsgJS,\n                                                                                                   noRoleMsgJs ) );\n        Event.observe( this.toPrimaryMove, "click", this.switchPrimary.bindAsEventListener( this, moveMsgJS ) );\n        Event.observe( this.toSecondaryMove, "click", this.switchUserRoleColumns.bindAsEventListener( this, true,\n                                                                                                      moveMsgJS,\n                                                                                                      noRoleMsgJs ) );\n        Event.observe( this.source, "change", this.focusSource.bindAsEventListener( this ) );\n        Event.observe( this.secondary, "change", this.focusSecondary.bindAsEventListener( this ) );\n\n        if(this.toPrimaryMove){\n          this.toPrimaryMove.setAttribute("class", "disableArrows");\n          this.getImage(this.toPrimaryMove).setAttribute("src", this.right_disabled_arrow);\n        }\n        if(this.toSecondaryMove){\n          this.toSecondaryMove.setAttribute("class", "disableArrows");\n          this.getImage(this.toSecondaryMove).setAttribute("src", this.right_disabled_arrow);\n        }\n        if(this.toSourceMove){\n          this.toSourceMove.setAttribute("class", "disableArrows");\n          this.getImage(this.toSourceMove).setAttribute("src", this.left_disabled_arrow);\n        }\n      }\n    },\n\n    getImage : function( moveElement )\n    {\n      return moveElement.childElements()[0];\n    },\n\n    focusSource : function( event )\n    {\n      if ( this.source.length <= 0 || this.source.selectedIndex == -1 ||\n           this.source.selectedIndex > this.source.length - 1 )\n      {\n        this.toPrimaryMove.setAttribute( "class", "disableArrows" );\n        this.toSecondaryMove.setAttribute( "class", "disableArrows" );\n        this.getImage(this.toPrimaryMove).setAttribute("src", this.right_disabled_arrow);\n        this.getImage(this.toSecondaryMove).setAttribute("src", this.right_disabled_arrow);\n      }\n      else\n      {\n        this.toPrimaryMove.removeAttribute( "class" );\n        this.toSecondaryMove.removeAttribute( "class" );\n        this.getImage(this.toPrimaryMove).setAttribute("src", this.right_arrow);\n        this.getImage(this.toSecondaryMove).setAttribute("src", this.right_arrow);\n      }\n    },\n\n    focusSecondary : function( event )\n    {\n      if ( this.secondary.length <= 0 || this.secondary.selectedIndex == -1 ||\n           this.secondary.selectedIndex > this.secondary.length - 1 )\n      {\n        this.toSourceMove.setAttribute( "class", "disableArrows" );\n        this.getImage(this.toSourceMove).setAttribute("src", this.left_disabled_arrow);\n      }\n      else\n      {\n        this.toSourceMove.removeAttribute( "class" );\n        this.getImage(this.toSourceMove).setAttribute("src", this.left_arrow);\n      }\n    },\n\n    switchPrimary : function( event, msg )\n    {\n      var indx;\n      indx = 0;\n\n      var sourceArray = this.source;\n      if ( sourceArray.selectedIndex >= 0 )\n      {\n        indx = sourceArray.selectedIndex;\n        var tmpOpt = this.getFromPrimary();\n\n        this.primaryValue.value = sourceArray.options[ indx ].value;\n        this.primary.value = sourceArray.options[ indx ].text;\n\n        sourceArray.options[ indx ].selected = false;\n        sourceArray.options[ indx ] = null;\n        sourceArray.options[ sourceArray.length ] = tmpOpt;\n      }\n      this.writeToSelectBoxValues( this.source, this.leftValues );\n      this.focusSource();\n\n      return false;\n    },\n    getFromPrimary : function()\n    {\n      var primaryRoleField = this.primaryValue;\n      var primaryField = this.primary;\n      return new Option( primaryField.value, primaryRoleField.value );\n    },\n    writeToSelectBoxValues : function( selectBox, hiddenName )\n    {\n      var i = 0;\n      var values = "";\n      while ( i < selectBox.length )\n      {\n        if ( i > 0 )\n        {\n          values += ",";\n        }\n        values += selectBox.options[ i ].value;\n        i++;\n      }\n      hiddenName.value = values;\n      return true;\n    },\n\n    switchUserRoleColumns : function( event, isSourceDest, msg, noRoleMsg )\n    {\n      var indx;\n      indx = 0;\n\n      var sourceArray = this.source;\n      var targetArray = this.secondary;\n\n      if ( !isSourceDest ) // If we are moving from Dest to Source\n      {\n        var temp = sourceArray;\n        sourceArray = targetArray;\n        targetArray = temp;\n      }\n\n      var rightIndex = 0;\n      var targetLength = targetArray.length;\n      while ( sourceArray.selectedIndex >= 0 )\n      {\n        indx = sourceArray.selectedIndex;\n        var tmpOpt = this.cloneMultipleRows( sourceArray.options[ indx ] );\n        if ( targetLength > 0 )\n        {\n          var i = targetLength;\n\n          while ( i > 0 )\n          {\n            var tmpOpt1 = this.cloneMultipleRows( targetArray.options[ i + rightIndex - 1 ] );\n            if ( tmpOpt1.textContent.localeCompare( tmpOpt.textContent ) > 0 )\n            {\n              targetArray.options[ i + rightIndex ] = tmpOpt1;\n            }\n            else\n            {\n              targetArray.options[ i + rightIndex ] = tmpOpt;\n              break;\n            }\n            i--;\n          }\n          if ( i == 0 )\n          {\n            targetArray.options[ i ] = tmpOpt;\n          }\n        }\n        else\n        {\n          // targetLength == 0\n          targetArray.options[ rightIndex ] = tmpOpt;\n        }\n        sourceArray.options[ indx ].selected = false;\n        // targetArray.options[rigthIndex].selected=true;\n        rightIndex = rightIndex + 1;\n        sourceArray.options[ indx ] = null;\n      } // end of while\n      this.writeToSelectBoxValues( this.source, this.leftValues );\n      this.writeToSelectBoxValues( this.secondary, this.rightValues );\n      this.focusSource();\n      this.focusSecondary();\n\n      return false;\n    },\n    cloneMultipleRows : function( opt )\n    {\n      return new Option( opt.text, opt.value, opt.defaultSelected, opt.selected );\n    }\n};\n\nwidget.StepGroup =\n{};\nwidget.StepGroup.toggleStepGroup = function( e, activeTabStr )\n{\n  var event = e || window.event;\n  var target = Event.findElement( event, \'li\' );\n  var tabs = $A( $( \'dataCollectionContainer\' ).getElementsByTagName( \'ul\' )[ 0 ].getElementsByTagName( \'li\' ) );\n  tabs.each( function( tab )\n  {\n    tab = $( tab );\n\n    if ( tab.id == target.id )\n    {\n      tab.addClassName( "active" );\n      $( tab.getAttribute( "bb:groupId" ) ).show();\n      $( \'activeTabSpanId_\' + tab.id ).innerHTML = activeTabStr;\n    }\n    else\n    {\n      tab.removeClassName( "active" );\n      $( tab.getAttribute( "bb:groupId" ) ).hide();\n      $( \'activeTabSpanId_\' + tab.id ).innerHTML = "";\n    }\n  } );\n  Event.stop( event );\n};\n/**\n * Show a specific step group\n *\n * @param number - the number of the group in order of the tabs at the top (e.g. 1 is the leftmost tab, then 2, 3, etc.)\n */\nwidget.StepGroup.showStepGroup = function( number )\n{\n  var target = $( \'stepGroupTab_\' + number );\n  var tabs = $A( $( \'dataCollectionContainer\' ).getElementsByTagName( \'ul\' )[ 0 ].getElementsByTagName( \'li\' ) );\n  tabs.each( function( tab )\n  {\n    tab = $( tab );\n    if ( tab.id == target.id )\n    {\n      tab.addClassName( "active" );\n      $( tab.getAttribute( "bb:groupId" ) ).show();\n    }\n    else\n    {\n      tab.removeClassName( "active" );\n      $( tab.getAttribute( "bb:groupId" ) ).hide();\n    }\n  } );\n};\n/**\n * Get the content block element to a specific step group\n *\n * @param number - the number of the group in order of the tabs at the top (e.g. 1 is the leftmost tab, then 2, 3, etc.)\n */\nwidget.StepGroup.getStepGroupContentBlock = function( number )\n{\n  var targetTab = $( \'stepGroupTab_\' + number );\n  return $( targetTab.getAttribute( "bb:groupId" ) );\n};\nwidget.StepGroup.showAllStepGroupsForSubmit = function()\n{\n  var tabs = $A( $( \'dataCollectionContainer\' ).getElementsByTagName( \'ul\' )[ 0 ].getElementsByTagName( \'li\' ) );\n  tabs.each( function( tab )\n  {\n    $( tab.getAttribute( "bb:groupId" ) ).show();\n  } );\n};\nwidget.StepGroup.revertAllStepGroupsAfterSubmit = function()\n{\n  var tabs = $A( $( \'dataCollectionContainer\' ).getElementsByTagName( \'ul\' )[ 0 ].getElementsByTagName( \'li\' ) );\n  tabs.each( function( tab )\n  {\n    if ( page.util.hasClassName( tab, \'active\' ) )\n    {\n      $( tab.getAttribute( "bb:groupId" ) ).show();\n    }\n    else\n    {\n      $( tab.getAttribute( "bb:groupId" ) ).hide();\n    }\n  } );\n};\nwidget.ShowUnsavedChanges = Class.create();\nwidget.ShowUnsavedChanges.prototype =\n{\n  initialize : function( dataCollectionContainer, skipTextArea )\n  {\n    widget.ShowUnsavedChanges.enabled = true;\n    widget.ShowUnsavedChanges.registerOnValueChangeCallback( widget.ShowUnsavedChanges.showIconsForUnsavedChanges );\n    var container = $( dataCollectionContainer );\n    var inputs = $A( container.getElementsByTagName( \'input\' ) );\n    var selects = $A( container.getElementsByTagName( \'select\' ) );\n    var textareas = $A( container.getElementsByTagName( \'textarea\' ) );\n    inputs.each( function( input )\n    {\n      input = $( input );\n      var type = input.type.toLowerCase();\n      if ( type == \'checkbox\' || type == \'radio\' )\n      {\n        input._defaultValue = input.checked;\n      }\n      else if ( type == \'hidden\' || type == \'text\' )\n      {\n        input._defaultValue = input.value;\n      }\n      else\n      {\n        input._defaultValue = \'\';\n      }\n      if ( type != \'hidden\' && type != \'button\' && type != \'submit\' )\n      {\n        input.observe( \'change\', widget.ShowUnsavedChanges.onValueChange.bindAsEventListener() );\n      }\n    }.bind( this ) );\n    selects.each( function( input ) // TODO: multiselect?\n    {\n      input = $( input );\n      input._defaultValue = input.selectedIndex;\n      input.observe( \'change\', widget.ShowUnsavedChanges.onValueChange.bindAsEventListener() );\n    }.bind( this ) );\n\n    if ( !skipTextArea || !skipTextArea )\n    {\n      textareas.each( function( input )\n      {\n        input = $( input );\n        input._defaultValue = input.value;\n        input.observe( \'change\', widget.ShowUnsavedChanges.onValueChange.bindAsEventListener() );\n      }.bind( this ) );\n    }\n  }\n};\n\nwidget.ShowUnsavedChanges.onValueChangeCallback = function()\n{\n}; // do nothing\nwidget.ShowUnsavedChanges.registerOnValueChangeCallback = function( callbackFunction )\n{\n  widget.ShowUnsavedChanges.onValueChangeCallback = callbackFunction;\n};\n\nwidget.ShowUnsavedChanges.dataElementsByStepGroup =\n{};\nwidget.ShowUnsavedChanges.onValueChange = function( event, elem )\n{\n  if ( widget.ShowUnsavedChanges.enabled )\n  {\n    var dataElement = null;\n    if ( event )\n    {\n      dataElement = Event.findElement( event, \'li\' );\n    }\n    else\n    {\n      dataElement = elem.parentNode;\n      while ( dataElement && dataElement.tagName.toLowerCase() != \'li\' )\n      {\n        dataElement = dataElement.parentNode;\n        if ( dataElement.tagName.toLowerCase() == \'body\' )\n        {\n          dataElement = null;\n        }\n      }\n      if ( dataElement )\n      {\n        dataElement = $( dataElement );\n      }\n    }\n    if ( !dataElement )\n    {\n      return;\n    }\n\n    var isDefault = true;\n    var inputs = $A( dataElement.getElementsByTagName( \'input\' ) );\n    var selects = $A( dataElement.getElementsByTagName( \'select\' ) );\n    var textareas = $A( dataElement.getElementsByTagName( \'textarea\' ) );\n    inputs.each( function( input )\n    {\n      var type = input.type.toLowerCase();\n      if ( type == \'checkbox\' || type == \'radio\' )\n      {\n        isDefault &= ( input.checked == input._defaultValue );\n      }\n      else if ( type == \'hidden\' || type == \'text\' )\n      {\n        isDefault &= ( input.value == input._defaultValue );\n      }\n    } );\n    selects.each( function( input ) // TODO: multiselect?\n    {\n      isDefault &= ( input.selectedIndex == input._defaultValue );\n    } );\n    textareas.each( function( input )\n    {\n      isDefault &= ( input.value == input._defaultValue );\n    } );\n\n    // trigger call back function\n    widget.ShowUnsavedChanges.onValueChangeCallback( isDefault, dataElement );\n\n  }\n};\n\nwidget.ShowUnsavedChanges.showIconsForUnsavedChanges = function( isDefault, dataElement )\n{\n  var imgs = dataElement.getElementsByTagName( \'img\' );\n  var unsavedImg = null;\n  for ( var i = 0; i < imgs.length; i++ )\n  {\n    if ( imgs[ i ].className.indexOf( \'unsavedChangeImg\' ) >= 0 )\n    {\n      unsavedImg = $( imgs[ i ] );\n      break;\n    }\n  }\n  if ( unsavedImg )\n  {\n    if ( isDefault )\n    {\n      dataElement.removeClassName( \'dirty\' );\n      unsavedImg.hide();\n    }\n    else\n    {\n      dataElement.addClassName( \'dirty\' );\n      unsavedImg.show();\n    }\n    widget.ShowUnsavedChanges.updateStepGroupIndicator();\n  }\n\n};\n\nwidget.ShowUnsavedChanges.updateStepGroupIndicator = function()\n{\n  if ( widget.ShowUnsavedChanges.enabled )\n  {\n    // Loop through each step group tab, and determine if an icon that indicates\n    // unsaved changes should be displayed in the tab itself\n    $$( \'#dataCollectionContainer ul li.stepGroupTab\' ).each( function( tab )\n    {\n      var stepGroup = $( tab.getAttribute( "bb:groupId" ) );\n      var img = $( tab.getElementsByTagName( \'img\' )[ 0 ] );\n      var link = $( tab.getElementsByTagName( \'a\' )[ 0 ] );\n      var dataElements = widget.ShowUnsavedChanges.dataElementsByStepGroup[ stepGroup.id ];\n      if ( !dataElements )\n      {\n        dataElements = stepGroup.getElementsByTagName( \'li\' );\n        widget.ShowUnsavedChanges.dataElementsByStepGroup[ stepGroup.id ] = dataElements;\n      }\n\n      var dirtyCount = 0;\n      for ( var i = 0; i < dataElements.length; i++ )\n      {\n        //If the data element is hidden, we do not want to include it in the count of dirty\n        //data elements.  Doing so could result in the dirty image on the step group displaying\n        //with no child data elements that display as dirty.\n        if ( dataElements[ i ].hasClassName( "dirty" ) && dataElements[ i ].getStyle( "display" ) !== "none" )\n        {\n          dirtyCount++;\n        }\n      }\n      if ( dirtyCount > 0 && !tab.isDirty )\n      {\n        img.show();\n        link.setStyle(\n        {\n          \'paddingLeft\' : \'20px\'\n        } );\n        tab.isDirty = true;\n      }\n      else if ( dirtyCount === 0 && tab.isDirty )\n      {\n        img.hide();\n        link.setStyle(\n        {\n          \'paddingLeft\' : \'\'\n        } );\n        tab.isDirty = false;\n      }\n    } );\n  }\n};\n// Call this when the value of a hidden data element changes that you want to\n// show an indicator for. Otherwise changing the value of the hidden element directly will\n// not cause an indicator to show.\nwidget.ShowUnsavedChanges.changeHiddenValue = function( hiddenElem, value )\n{\n  hiddenElem.value = value;\n  if ( widget.ShowUnsavedChanges.enabled )\n  {\n    widget.ShowUnsavedChanges.onValueChange( null, hiddenElem );\n  }\n};\nwidget.ShowUnsavedChanges.enabled = false;\n\n/**\n * Supports a counter widget attached to a textbox -- it keeps track of the number of characters in the text box, and\n * updates a counter whenever that number changes. The counter turns red, and begins counting backwards, when the max\n * number of charters is exceeded.\n */\nwidget.TextBoxCounter = Class.create();\nwidget.TextBoxCounter.prototype =\n{\n\n    /**\n     * Contructor\n     *\n     * @param textBoxId The id of the textbox we\'re counting from\n     * @param counterId The id of the element that countains the count\n     * @param maxCharCount The max number of characters supported by this textbox\n     * @param charactersRemainingLabel The label for the character count element\n     * @param charactersOverLimitLabel The alternate label for the character element, for when the max # of characters\n     *          has been exceeded.\n     */\n    initialize : function( textBoxId, counterId, maxCharCount, charactersRemainingLabel, charactersOverLimitLabel )\n    {\n\n      this.textBoxElement = $( textBoxId );\n      this.counterElement = $( counterId );\n      this.maxCharCount = maxCharCount;\n      this.countLabelElement = this.counterElement.up().childNodes[ 0 ];\n\n      this.charactersRemainingLabel = charactersRemainingLabel;\n      this.charactersOverLimitLabel = charactersOverLimitLabel;\n\n      // watch all keystrokes in the text area, and update the counter accordingly\n      this.textBoxElement.observe( \'keyup\', this.updateCount.bindAsEventListener( this ) );\n\n      // update the initial count\n      this.updateCount();\n\n      this.registerCounter( textBoxId );\n\n    },\n\n    /**\n     * Registers the current counter with the document, so that it can be accessed from anywhere on the page.\n     *\n     * @param id The id with which this counter can be accessed\n     */\n    registerCounter : function( id )\n    {\n      if ( !widget.TextBoxCounter.counters )\n      {\n        widget.TextBoxCounter.counters = [];\n      }\n      widget.TextBoxCounter.counters[ id ] = this;\n    },\n\n    /**\n     * Update the counter.\n     *\n     * @param event The event that prompted this update, if any.\n     */\n    updateCount : function( event )\n    {\n\n      var chars = this.textBoxElement.value.length;\n\n      // max character count exceeded\n      if ( chars > this.maxCharCount )\n      {\n        this.counterElement.update( chars - this.maxCharCount ).addClassName( \'bad\' );\n        this.countLabelElement.nodeValue = this.charactersOverLimitLabel;\n      }\n\n      // max character count not exceeded\n      else if ( chars <= this.maxCharCount )\n      {\n        this.counterElement.update( this.maxCharCount - chars ).removeClassName( \'bad\' );\n        this.countLabelElement.nodeValue = this.charactersRemainingLabel;\n      }\n\n    }\n};\n\nwidget.ColorPalettePicker = Class.create();\nwidget.ColorPalettePicker.prototype =\n{\n    initialize : function( onChange, themeChangeElementId )\n    {\n      widget.ColorPalettePicker.picker = this;\n\n      this.onChange = onChange;\n      var palettes = [];\n      $A( $( \'paletteLibraryPanel\' ).getElementsByTagName( \'li\' ) ).each( function( li )\n      {\n        if ( page.util.hasClassName( li, \'palette\' ) )\n        {\n          palettes.push( $( li ) );\n        }\n      } );\n      this.palettes = palettes;\n      this.libraryOpen = false;\n\n      this.paletteLibraryPanel = $( \'paletteLibraryPanel\' );\n      this.paletteLibraryButton = $( \'paletteLibraryButton\' );\n\n      var updateHandler = this.updateCurrentSelection.bindAsEventListener( this );\n      // this.paletteLibraryPanel.toggleLibrary();\n      if ( this.palettes )\n      {\n        this.palettes.each( function( palette )\n        {\n          Event.observe( palette, "click", updateHandler );\n        } );\n      }\n      if ( this.paletteLibraryButton )\n      {\n        Event.observe( \'paletteLibraryButtonLink\', "click", this.toggleLibrary.bindAsEventListener( this ) );\n      }\n      if ( themeChangeElementId !== "" )\n      {\n        Event.observe( themeChangeElementId, "change", this.changePaletteThemeTypeStyles.bindAsEventListener( this ) );\n      }\n    },\n\n    changePaletteThemeTypeStyles : function( event )\n    {\n      // IE does not support currentTarget for events,\n      // so use the srcElement instead.\n      var dropdown = event.currentTarget;\n      if( !dropdown )\n      {\n        dropdown = event.srcElement;\n      }\n\n      var themeExtRef = $F( dropdown );\n      var extRefToThemeTypeJson = $F( "themeExtRefToThemeTypeJson" );\n      var extRefToThemeTypeMap = this.convertJsonToObject( decodeURIComponent( extRefToThemeTypeJson ) );\n\n      var themeType = extRefToThemeTypeMap[themeExtRef];\n\n      var mapKey = null;\n\n      this.palettes.each( function( palette )\n      {\n        if( palette.id === "currentsystemthemecolorpalette" )\n        {\n          mapKey = "theme_type_" + themeExtRef;\n        }\n        else\n        {\n          if( themeType !== null )\n          {\n            mapKey = "theme_type_" + themeType;\n          }\n          else\n          {\n            mapKey = "theme_type_";\n          }\n        }\n        var styleJson = $F( palette.down(\'input[type=hidden]\') );\n        var styleMap = this.convertJsonToObject( decodeURIComponent( styleJson ) );\n\n        var schemePreviewStyle = styleMap[mapKey][\'schemePreview\'];\n        var schemePreviewHeadStyle = styleMap[mapKey][\'schemePreviewHead\'];\n        var schemePreviewBodyStyle = styleMap[mapKey][\'schemePreviewBody\'];\n        var modulePreviewStyle = styleMap[mapKey][\'moduleBorder\'];\n        var modulePreviewHeadStyle = styleMap[mapKey][\'moduleTitle\'];\n        var modulePreviewBodyStyle = styleMap[mapKey][\'moduleBody\'];\n\n        palette.down(\'.schemePreview\').writeAttribute("style", schemePreviewStyle);\n        palette.down(\'.schemePreviewHead\').writeAttribute("style", schemePreviewHeadStyle);\n        palette.down(\'.schemePreviewBody\').writeAttribute("style", schemePreviewBodyStyle);\n        palette.down(\'.modulePreview\').writeAttribute("style", modulePreviewStyle);\n        palette.down(\'.modulePreviewHead\').writeAttribute("style", modulePreviewHeadStyle);\n        palette.down(\'.modulePreviewBody\').writeAttribute("style", modulePreviewBodyStyle);\n\n      }, this );\n    },\n\n    convertJsonToObject : function( json )\n    {\n      if ( typeof ( JSON ) === \'object\' && typeof ( JSON.parse ) === \'function\' )\n      {\n        return  JSON.parse( json );\n      }\n      else\n      {\n        return eval( \'(\' + json + \')\' );\n      }\n    },\n\n    toggleLibrary : function( event )\n    {\n      var img = this.paletteLibraryButton.getElementsByTagName( \'img\' )[ 0 ];\n      if ( this.libraryOpen )\n      {\n        // Collapse the library.\n        img.src = getCdnURL( "/images/db/p.gif" );\n        img.alt = page.bundle.getString( "dynamictree.expand" );\n        this.paletteLibraryPanel.hide();\n        this.libraryOpen = false;\n      }\n      else\n      {\n        // Expand the library.\n        img.src = getCdnURL( "/images/db/m.gif" );\n        img.alt = page.bundle.getString( "dynamictree.collapse" );\n        this.paletteLibraryPanel.show();\n        this.libraryOpen = true;\n      }\n\n      // stop the event if exists; there will not be an event if called on page onLoad\n      if ( event )\n      {\n        Event.stop( event );\n      }\n    },\n\n    selectColorPaletteByExtRef : function( extRef )\n    {\n      var eventElement = $( extRef );\n      this.selectColorPaletteByElement( eventElement );\n    },\n\n    selectColorPaletteByElement : function( eventElement )\n    {\n      this.palettes.each( function( p )\n      {\n        if ( p.hasClassName( "selected" ) )\n        {\n          p.removeClassName( \'selected\' );\n        }\n      } );\n\n      var selPal = eventElement;\n      while ( selPal && selPal.tagName != \'LI\' )\n      {\n        selPal = selPal.parentNode;\n        if ( selPal.tagName == \'BODY\' )\n        {\n          selPal = null;\n        }\n      }\n      selPal.addClassName( \'selected\' );\n      widget.ShowUnsavedChanges.changeHiddenValue( $( \'currentPaletteExtRef\' ),\n                                                   selPal.id == \'currentsystemthemecolorpalette\' ? \'\' : selPal.id );\n      eval( this.onChange );\n      $( \'currentPaletteLabel\' ).update( $( selPal.id + \'_label\' ).innerHTML );\n      this.copyStyles( selPal.down( \'.schemePreview\' ), $( \'currentPalettePreview\' ) );\n      this.copyStyles( selPal.down( \'.schemePreviewHead\' ), $( \'currentPalettePreviewHead\' ) );\n      this.copyStyles( selPal.down( \'.schemePreviewBody\' ), $( \'currentPalettePreviewBody\' ) );\n      this.copyStyles( selPal.down( \'.modulePreview\' ), $( \'currentModulePalettePreview\' ) );\n      this.copyStyles( selPal.down( \'.modulePreviewHead\' ), $( \'currentModulePalettePreviewHead\' ) );\n      this.copyStyles( selPal.down( \'.modulePreviewBody\' ), $( \'currentModulePalettePreviewBody\' ) );\n      $( \'selectedPalette\' ).show();\n\n    },\n    updateCurrentSelection : function( event )\n    {\n      var eventElement = Event.element( event );\n      this.selectColorPaletteByElement( eventElement );\n      Event.stop( event );\n    },\n\n    copyStyles : function( s, d )\n    {\n      d.style.cssText = s.style.cssText;\n    }\n\n};\nwidget.ColorPalettePicker.picker = null;\n\n/**\n * node picker\n */\nwidget.MINodePicker = Class.create();\n\n/** Constants used for the picker */\nwidget.MINodePicker.Constants =\n{\n    EXISTING_NODE_SUFFIX : "",\n    EXISTING_NODE_DELETE_SUFFIX : "",\n    NEW_NODE_SUFFIX : ""\n};\n\nwidget.MINodePicker.prototype =\n{\n    initConstants : function()\n    {\n      widget.MINodePicker.Constants.EXISTING_NODE_SUFFIX = page.bundle\n          .getString( "nodePicker.const.existingNodeSuffix" );\n      widget.MINodePicker.Constants.EXISTING_NODE_DELETE_SUFFIX = page.bundle\n          .getString( "nodePicker.const.existingNodeDeleteSuffix" );\n      widget.MINodePicker.Constants.NEW_NODE_SUFFIX = page.bundle.getString( "nodePicker.const.newNodeSuffix" );\n    },\n\n    /**\n     * Creates a new node picker\n     *\n     * @param baseElementName the base name for the node picker elements\n     * @param pickerList the javascript object representing the picker list (of currently attached files)\n     * @param allowMultipleSelect boolean indicating whether the picker should allow single or multiple select\n     * @param entitlements comma delimited list of entitlement UIDs in which to check on node search\n     * @param popupInstructions key value pair of bundle name and bundle key for instructions to be displayed in the pop\n     *          up\n     * @param addPrimaryEntitlement Entitlement required to display primary radio button.\n     * @param removeNodeEntitlement Entitlement required to display remove node link.\n     * @param javascriptName The Javascript callback function defined by the opener. Function takes an array of objects as parameter.\n     * @param alias Nodes are sometimes called Location or BusinessUnit. Caller can specify what terminology the picker should use.\n     *              This value is fully supported only for button-only pickers i.e. when javascriptName is set.\n     */\n    initialize : function( baseElementName, pickerList, allowMultipleSelect, entitlements, popupInstructions, addPrimaryEntitlement, removeNodeEntitlement, javascriptName, alias )\n    {\n      this.initConstants();\n\n      this.baseElementName = baseElementName;\n      this.allowMultipleSelect = allowMultipleSelect;\n      this.entitlements = entitlements;\n      this.javascriptName = javascriptName;\n      this.alias = alias;\n\n      this.nodePickerPopupButton = $( this.baseElementName + \'_nodeBrowseButton\' );\n\n      this.nodePickerUrl = "/webapps/blackboard/execute/institutionalHierarchy/nodePicker?cmd=openPicker&allowMultipleSelect=" + this.allowMultipleSelect + "&instructionKey=" + popupInstructions + "&entitlements=" + this.entitlements + "&addPrimaryEntitlement=" + addPrimaryEntitlement + "&removeNodeEntitlement=" + removeNodeEntitlement;\n      if ( this.javascriptName )\n      {\n        this.nodePickerUrl +=  "&callback=" + this.javascriptName;\n      }\n      if ( this.alias && this.alias !== \'Node\' )\n      {\n        this.nodePickerUrl += \'&alias=\' + this.alias;\n      }\n\n      Event.observe( this.nodePickerPopupButton, "click", this.onNodeBrowse.bindAsEventListener( this ) );\n\n      this.pickerList = pickerList;\n      this.selectedNodesListContainer = $( this.baseElementName + \'_listHtml\' );\n\n      // make sure that all removedNodes are hidden\n      if ( this.selectedNodesListContainer )\n      {\n        var removedNodes = this.selectedNodesListContainer\n            .getElementsBySelector( \'input[name=\' + this.baseElementName + widget.MINodePicker.Constants.EXISTING_NODE_DELETE_SUFFIX + \']\' );\n        removedNodes.each( function( node )\n        {\n          node.up( \'tr\' ).hide();\n        } );\n      }\n\n      var showList;\n\n      // For multiple node picker, DOM contains a table structure for displaying the attached nodes\n      if ( this.allowMultipleSelect )\n      {\n        showList = this.selectedNodesListContainer && this.pickerList && this.pickerList.tableBody && !this.pickerList.tableBody\n            .empty();\n      }\n      // For single node picker, the attached node is contained within a span element\n      else\n      {\n        showList = this.selectedNodesListContainer && this.selectedNodesListContainer.select( "input.selectedNodeData" ) && this.pickerList;\n      }\n\n      if ( this.pickerList && this.pickerList.tableBody )\n      {\n        // If no visible row then hide the table label and headers.\n        if ( !this.pickerList.tableBody.select( "tr" ).any( function( row )\n        {\n          return row.visible();\n        } ) )\n        {\n          showList = false;\n        }\n      }\n\n      this.showHideSelectedNodesList( showList );\n\n      widget.MINodePicker.registerNodePicker( this );\n    },\n\n    /**\n     * Pop up the node search window from which to pick nodes\n     */\n    onNodeBrowse : function( event )\n    {\n      this.nodePickerWindow = null;\n      var windowId = new Date().getTime();\n      if ( $( \'primaryNodeIdStr\' ) )\n      {\n        this.nodePickerUrl += \'&primaryNodeIdStr=\' + $F( \'primaryNodeIdStr\' );\n      }\n      if ( $( \'objectType\' ) )\n      {\n        this.nodePickerUrl += \'&objectType=\' + $F( \'objectType\' );\n      }\n      this.nodePickerWindow = popup.launchPicker( this.nodePickerUrl, windowId, 1000, 700 );\n      if ( this.nodePickerWindow )\n      {\n        this.nodePickerWindow.opener.customHandler = this.onNodePick.bind( this );\n      }\n      Event.stop( event );\n    },\n\n    /**\n     * Callback called after node(s) have been selected from the node picker pop up. This method updates the UI list of\n     * currently select nodes.\n     *\n     * @param selectedNodesObjArr The array of currently selected nodes from the picker\n     */\n    onNodePick : function( selectedNodesObjArr )\n    {\n      this.showHideSelectedNodesList( true );\n      var existingNodes;\n\n      if ( this.allowMultipleSelect )\n      {\n        // Array of existing selected nodes in the node picker list\n        existingNodes = this.selectedNodesListContainer.down( "tbody" ).select( "input.selectedNodeData" );\n      }\n      else\n      {\n        // Existing selected node in the node picker list for single node picker\n        existingNodes = this.selectedNodesListContainer.select( "input.selectedNodeData" );\n      }\n\n      // TODO: This block of code is specific to data integration page and should be taken out where it actually\n      // belongs.\n      // Perhaps, defining an event in the picker and have data integration page register for that event and have this\n      // logic implemented would be the right thing to do.\n      if ( selectedNodesObjArr && selectedNodesObjArr.length !== 0 )\n      {\n        // Switch the radio button selection to Create hierarchy under the specified entity (for single node pickers)\n        if ( $( "selectedRoot" ) )\n        {\n          $( "selectedRoot" ).checked = true;\n        }\n      }\n\n      /*\n       * For each selected node, add the node to the list if it is a newly selected node, otherwise unhide the node if\n       * it is an existing selection that has been marked for delete. Specifically: - If node is an existing selected\n       * node and marked for delete and hidden, then unmark and show - If node is an existing selected node and not\n       * marked for delete and showing, then do nothing - If node is a newly selected node and is not already there, add\n       * the row - If node is a newly selected node and is already there, then do nothing\n       */\n      selectedNodesObjArr.each( function( node )\n      {\n        // See if the picked node is already in the list of nodes\n        var existingNode;\n        existingNodes.each( function( inputEle )\n        {\n          if ( node.nodeIdStr === inputEle.value )\n          {\n            existingNode = inputEle;\n            if ( existingNode.disabled && existingNode.checked )\n            {\n              // If its a disabled primary node then restore the value of it in hidden param.\n              $( this.baseElementName + \'_disabledPrimaryNode\' ).value = node.nodeIdStr;\n            }\n            throw $break;\n          }\n        } );\n\n        // If not, then add this newly picked node to list\n        if ( !existingNode )\n        {\n          var primaryRadioChecked;\n          var existingPrimaryNodeRadios = this.selectedNodesListContainer\n              .select( \'input[name=\' + this.baseElementName + \'_PrimaryNode]\' );\n          if ( existingPrimaryNodeRadios.all( function( radio )\n          {\n            return !radio.checked;\n          } ) )\n          {\n            primaryRadioChecked = true;\n          }\n          // For multiple node picker, DOM contains a table structure for displaying the attached nodes\n          if ( this.allowMultipleSelect )\n          {\n            // This calls the cell generator methods for each column in the "currently selected nodes" list\n            this.pickerList.addRow( this.baseElementName, node, this.nodePickerWindow, primaryRadioChecked );\n          }\n          // For single node picker, the attached node is contained within a span element\n          else\n          {\n            this.selectedNodesListContainer.innerHTML = "";\n            this.pickerList.cellGenerators.each( function( generator, index )\n            {\n              var args = [];\n              args.push( this.baseElementName, node, this.nodePickerWindow );\n              this.selectedNodesListContainer.innerHTML += generator.apply( window, args );\n            }.bind( this ) );\n          }\n        }\n        else\n        {\n          /*\n           * If picked node is already in the list AND is an existing selected node that is marked for delete and\n           * hidden, then unmark node and show in list.\n           */\n          if ( existingNode.name.endsWith( widget.MINodePicker.Constants.EXISTING_NODE_DELETE_SUFFIX ) )\n          {\n            existingNode.name = existingNode.name.sub( widget.MINodePicker.Constants.EXISTING_NODE_DELETE_SUFFIX,\n                                                       widget.MINodePicker.Constants.EXISTING_NODE_SUFFIX );\n            if ( this.allowMultipleSelect )\n            {\n              existingNode.up( "tr" ).show();\n            }\n          }\n        }\n      }.bind( this ) );\n    },\n\n    /**\n     * Shows or hides the selected nodes list\n     *\n     * @param show boolean to indicate show or hide\n     */\n    showHideSelectedNodesList : function( show )\n    {\n      if ( this.selectedNodesListContainer )\n      {\n        return show ? this.selectedNodesListContainer.show() : this.selectedNodesListContainer.hide();\n      }\n    }\n};\n\n/**\n * Removes the specified node selection from the list. Should be called from an onclick handler on a link in the\n * currently selected nodes table.\n */\nwidget.MINodePicker.removeSelectedNode = function( event, removeLink, baseElementName )\n{\n  var e = event || window.event;\n\n  // Have user confirm removal of selected node\n  if ( confirm( page.bundle.getString( "nodePicker.nodeRemoveConfirmMsg" ) ) )\n  {\n    var visibleRows = [];\n    var picker = widget.MINodePicker.getNodePicker( baseElementName );\n    var hiddenNodeDataEle;\n    // For multiple node picker, DOM contains a table structure for displaying the attached nodes\n    if ( picker.allowMultipleSelect )\n    {\n      // Get references to DOM elements in the list\n      removeLink = $( removeLink );\n      var rowToHideRemove = removeLink.up( "tr" );\n      var tbodyEle = rowToHideRemove.up( "tbody" );\n      hiddenNodeDataEle = rowToHideRemove.down( "input.selectedNodeData" );\n\n      var primaryNodeRadioSelector = \'input[name=\' + baseElementName + \'_PrimaryNode]\';\n      var primaryNodeRadioInCurrentRow = rowToHideRemove.down( primaryNodeRadioSelector );\n      if ( primaryNodeRadioInCurrentRow )\n      {\n        // Check if removed node is selected as a primary node\n        if ( primaryNodeRadioInCurrentRow.checked )\n        {\n          if ( primaryNodeRadioInCurrentRow.disabled )\n          {\n            // A disabled primary node is removed from UI then nullify the value of hidden param storing its value.\n            $( baseElementName + \'_disabledPrimaryNode\' ).value = \'\';\n          }\n          else\n          {\n            // Get the next node which is not checked as primary and is enabled.\n            var nextNode = picker.selectedNodesListContainer.select( primaryNodeRadioSelector ).find( function( radio )\n            {\n              return ( !radio.checked && !radio.disabled && radio.up( \'tr\' ).visible() );\n            } );\n\n            if ( nextNode )\n            {\n              nextNode.checked = true;\n            }\n            else\n            {\n              // In case there\'s no next node with primary node radio button, then uncheck current primary manually\n              primaryNodeRadioInCurrentRow.checked = false;\n            }\n          }\n        }\n      }\n\n      // Hide or remove the row\n\n      // If this is an existing selected node\n      if ( hiddenNodeDataEle.name.endsWith( widget.MINodePicker.Constants.EXISTING_NODE_SUFFIX ) )\n      {\n        // "mark" for deletion\n        hiddenNodeDataEle.name = hiddenNodeDataEle.name.sub( widget.MINodePicker.Constants.EXISTING_NODE_SUFFIX,\n                                                             widget.MINodePicker.Constants.EXISTING_NODE_DELETE_SUFFIX );\n        // hide\n        rowToHideRemove.hide();\n      }\n      // If is a newly selected node\n      else if ( hiddenNodeDataEle.name.endsWith( widget.MINodePicker.Constants.NEW_NODE_SUFFIX ) )\n      {\n        // remove the row from the DOM\n        Element.remove( rowToHideRemove );\n      }\n\n      tbodyEle.select( "tr" ).each( function( row )\n      {\n        if ( row.visible() )\n        {\n          visibleRows.push( row );\n        }\n      } );\n    }\n    // For single node picker, the attached node is contained within a span element\n    else\n    {\n      hiddenNodeDataEle = picker.selectedNodesListContainer.down( "input.selectedNodeData" );\n\n      // Hide or remove the row\n\n      // If this is an existing selected node\n      if ( hiddenNodeDataEle.name.endsWith( widget.MINodePicker.Constants.EXISTING_NODE_SUFFIX ) )\n      {\n        // "mark" for deletion\n        hiddenNodeDataEle.name = hiddenNodeDataEle.name.sub( widget.MINodePicker.Constants.EXISTING_NODE_SUFFIX,\n                                                             widget.MINodePicker.Constants.EXISTING_NODE_DELETE_SUFFIX );\n      }\n      // If is a newly selected node, clear the span content\n      else if ( hiddenNodeDataEle.name.endsWith( widget.MINodePicker.Constants.NEW_NODE_SUFFIX ) )\n      {\n        picker.selectedNodesListContainer.innerHTML = "";\n      }\n    }\n\n    // If there are no more selected nodes, hide some UI elements\n\n    if ( visibleRows.length === 0 )\n    {\n      // Hide the whole selected nodes table\n      picker.showHideSelectedNodesList( false );\n\n      // TODO: This block of code is specific to data integration page and should be taken out where it actually\n      // belongs.\n      // Perhaps, defining an event in the picker and have data integration page register for that event and have this\n      // logic implemented would be the right thing to do.\n      // Switch the radio button selection to Create hierarchy under the top level (for single node pickers)\n      if ( $( "topLevelRoot" ) )\n      {\n        $( "topLevelRoot" ).checked = true;\n      }\n    }\n  }\n\n  Event.stop( e );\n};\n\n/**\n * A registry of defined node pickers and methods to access this registry\n */\nwidget.MINodePicker.nodePickers =\n{};\n\nwidget.MINodePicker.registerNodePicker = function( nodePicker )\n{\n  widget.MINodePicker.nodePickers[ nodePicker.baseElementName ] = nodePicker;\n};\nwidget.MINodePicker.unRegisterNodePicker = function( nodePicker )\n{\n  delete widget.MINodePicker.nodePickers[ nodePicker.baseElementName ];\n};\nwidget.MINodePicker.getNodePicker = function( baseElementName )\n{\n  return widget.MINodePicker.nodePickers[ baseElementName ];\n};\n\n/**\n * Cell generators for the currently selected nodes table. Mostly copies what is in multiInstNodePickerListElement.vm.\n */\nwidget.MINodePicker.cellGenerators =\n{\n    /**\n     * Dynamic rendering of a cell in the node "Name" column\n     */\n    nodeName : function( pickerNameStr, selectedNodeObj, nodePickerWindow )\n    {\n      var result = \'<input type="hidden" name="\' + pickerNameStr + widget.MINodePicker.Constants.NEW_NODE_SUFFIX + \'" value="\' + selectedNodeObj.nodeIdStr + \'" class="selectedNodeData">\';\n      result += \'<img src="\' + getCdnURL( "/images/ci/ng/entity_small.png" ) + \'" alt="">\';\n      result += selectedNodeObj.nodeName;\n      return result;\n    },\n\n    /**\n     * Dynamic rendering of a cell in the node "Primary Node" column\n     */\n    nodePrimary : function( pickerNameStr, selectedNodeObj, nodePickerWindow, primaryRadioChecked )\n    {\n\n      var result = \'<input type="radio" id="\' + selectedNodeObj.nodeIdStr + \'_Primary\' + \'" name="\' + pickerNameStr + \'_PrimaryNode" value="\' + selectedNodeObj.nodeIdStr + \'" class="selectedNodeData"\';\n      if ( nodePickerWindow.document.getElementById( selectedNodeObj.nodeIdStr + \'_disableRadio\' ).value == \'true\' )\n      {\n        result += \' disabled\';\n      }\n      if ( primaryRadioChecked )\n      {\n        result += \' checked\';\n      }\n      result += \' >\';\n\n      // Since values of disabled radio element doesn\'t go through the request, adding hidden param here to store its\n      // value.\n      if ( nodePickerWindow.document.getElementById( selectedNodeObj.nodeIdStr + \'_disableRadio\' ).value == \'true\' && primaryRadioChecked )\n      {\n        result += \'<input type="hidden" id="\' + pickerNameStr + \'_disabledPrimaryNode" name="\' + pickerNameStr + \'_PrimaryNode" value="\' + selectedNodeObj.nodeIdStr + \'" />\';\n      }\n\n      return result;\n    },\n\n    /**\n     * Dynamic rendering of a cell in the remove node column\n     */\n    nodeRemove : function( pickerNameStr, selectedNodeObj, nodePickerWindow )\n    {\n\n      if ( nodePickerWindow.document.getElementById( selectedNodeObj.nodeIdStr + \'_canRemoveObject\' ).value == \'true\' )\n      {\n        var result = \'<img src="\' + getCdnURL( "/images/ci/icons/x_ia.gif" ) + \'" alt="">\';\n        result += \'<a href="#" onclick="widget.MINodePicker.removeSelectedNode(event, this, \';\n        result += "\'" + pickerNameStr + "\');";\n        result += \'">\' + page.bundle.getString( "nodePicker.nodeRemoveLabel" );\n        result += \'</a>\';\n        return result;\n      }\n      else\n      {\n        return \'\';\n      }\n    }\n};\n\nwidget.LockUnlockToggle = {};\n\nwidget.LockUnlockToggle.toggleAvail = function( element, id, onTitle, offTitle )\n{\n\tid = unescape( id );\n\tvar el = $(element);\n\tvar checkbox = $( id );\n\tvar toggleLink = $( \'toggle_link_\' + id );\n\tvar hiddenInput = $( \'hidden_\' + id );\n\tvar isOn = hiddenInput.value === \'true\';\n\tif ( el.id === id ) {\n\t  // Checkbox change event happens after the state of the checkbox changes\n\t  // so we need to get the previous value (i.e. invert it)\n\t  isOn = !checkbox.checked;\n\t}\n\tif ( !isOn )\n\t{\n\t  checkbox.checked = true;\n\t  checkbox.value = "true";\n\t  checkbox.title=unescape(onTitle);\n\t  hiddenInput.value = "true";\n\t  toggleLink.removeClassName( \'course-availability-button course-available\' );\n\t  toggleLink.addClassName( \'course-availability-button course-unavailable\' );\n\t  toggleLink.title=unescape(onTitle);\n\t  toggleLink.setAttribute( "aria-label", unescape(onTitle) );\n    toggleLink.setAttribute( "aria-checked", "true" );\n    el.blur();\n\t}\n\telse\n\t{\n\t  checkbox.checked = false;\n\t  checkbox.value = "false";\n\t  checkbox.title=unescape(offTitle);\n\t  hiddenInput.value = "false";\n\t  toggleLink.removeClassName( \'course-availability-button course-unavailable\' );\n\t  toggleLink.addClassName( \'course-availability-button course-available\' );\n\t  toggleLink.title=unescape(offTitle);\n\t  toggleLink.setAttribute( "aria-label", unescape(offTitle) );\n    toggleLink.setAttribute( "aria-checked", "false" );\n    el.blur();\n\t}\n\ttoggleLink.setAttribute( "aria-labelledby", id );\n}\n\n/**\n * This returns the boolean state of the toggle with the given id.\n * If the toggle with the given id does not exist, false is returned.\n *\n * @param id Id of the toggle to get the state from\n */\nwidget.LockUnlockToggle.getToggleState = function( id )\n{\n  var hiddenInput = $( \'hidden_\' + id );\n  return hiddenInput ? hiddenInput.value === \'true\' : false;\n}\n\nwidget.OnOffToggle = {};\n\n/**\n * This toggles the on/off button visually and updates the hidden input.\n *\n * Also keeps the link and checkbox in sync.\n *\n * @param element the element that triggered the toggle (either the link or the checkbox)\n * @param id the id of the toggle\n */\nwidget.OnOffToggle.toggleAvail = function( element, id, onTitle, offTitle )\n{\n  id = unescape( id );\n  var el = $(element);\n  var checkbox = $( id );\n  var toggleLink = $( \'toggle_link_\' + id );\n  var hiddenInput = $( \'hidden_\' + id );\n  var isOn = hiddenInput.value === \'true\';\n  if ( el.id === id ) {\n    // Checkbox change event happens after the state of the checkbox changes\n    // so we need to get the previous value (i.e. invert it)\n    isOn = !checkbox.checked;\n  }\n  if ( !isOn )\n  {\n    checkbox.checked = true;\n    checkbox.value = "true";\n    checkbox.title=unescape(onTitle);\n    hiddenInput.value = "true";\n    toggleLink.removeClassName( \'read-off\' );\n    toggleLink.addClassName( \'read-on\' );\n    toggleLink.down().update( page.bundle.getString( \'action.on\' ) );\n    toggleLink.title=unescape(onTitle);\n    toggleLink.setAttribute( "aria-label", unescape(onTitle) );\n    toggleLink.setAttribute( "aria-checked", "true" );\n  }\n  else\n  {\n    checkbox.checked = false;\n    checkbox.value = "false";\n    checkbox.title=unescape(offTitle);\n    hiddenInput.value = "false";\n    toggleLink.removeClassName( \'read-on\' );\n    toggleLink.addClassName( \'read-off\' );\n    toggleLink.down().update( page.bundle.getString( \'action.off\' ) );\n    toggleLink.title=unescape(offTitle);\n    toggleLink.setAttribute( "aria-label", unescape(offTitle) );\n    toggleLink.setAttribute( "aria-checked", "false" );\n  }\n  toggleLink.setAttribute( "aria-labelledby", id );\n};\n\n/**\n * This returns the boolean state of the toggle with the given id.\n * If the toggle with the given id does not exist, false is returned.\n *\n * @param id Id of the toggle to get the state from\n */\nwidget.OnOffToggle.getToggleState = function( id )\n{\n  var hiddenInput = $( \'hidden_\' + id );\n  return hiddenInput ? hiddenInput.value === \'true\' : false;\n}\n'