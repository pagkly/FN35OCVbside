b'blob 8019\x00import os\nimport cv2\nimport cv2 as cv\nimport numpy as np\nfrom operator import itemgetter\ndir0=os.path.dirname(os.path.realpath(__file__))\ndef everyletter(imgdir):\n    #https://stackoverflow.com/questions/30506126/open-cv-error-215-scn-3-scn-4-in-function-cvtcolor\n    img = cv.imread(imgdir,0)\n    imgc = cv.imread(imgdir)\n    #imgc=cv2.copyMakeBorder(img,0,0,0,0,cv2.BORDER_REPLICATE)\n    # Taking a matrix of size 5 as the kernel\n    kernel = np.ones((2,1), np.uint8)\n    \n    #hsv = cv2.cvtColor(imgc, cv2.COLOR_BGR2HSV)\n    #lowerb = np.array([0,0,0])\n    #upperb = np.array([180, 255, 80])\n    #blackmask = cv2.inRange(hsv,lowerb,upperb)\n    #cv2.imshow(\'HSV\', hsv)\n    #cv2.imshow(\'MASK\', blackmask)\n    #cv2.waitKey(0)\n\n    ret, thresh = cv2.threshold(img, 127, 255, cv.THRESH_BINARY)\n    img_erosion=cv2.erode(thresh, kernel, iterations=1)\n    #cv2.imshow(\'BW\', thresh)\n    cv2.imshow(\'IE\', img_erosion)\n    cv2.waitKey(0)\n \n    # The first parameter is the original image,\n    # kernel is the matrix with which image is \n    # convolved and third parameter is the number \n    # of iterations, which will determine how much \n    # you want to erode/dilate a given image.\n    im2, contours, hierarchy = cv2.findContours(img_erosion, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n    #print(contours)\n    #cv2.drawContours(imgc, contours, -1, (0,255,0), 3)\n    listofcd=[]\n    for contour in contours:\n        [x,y,w,h] = cv2.boundingRect(contour)\n        listofcd.append([x,y,w,h])\n    #print(listofcd)\n    ##listofcd=sorted(listofcd, key=itemgetter(1,0))\n    #for c in listofcd:\n    #    for i in listofcd:\n    #        if c[0] in range(i[0],i[0]+5) and c[1] in range(c[1]-20,c[1]+10) and c!=i:\n    #            listofcd.remove(i)\n    #            #print(i)\n    countrect=0\n    for i in range(0,len(listofcd)):\n        [x,y,w,h]=listofcd[i]\n        if i+1!=len(listofcd):\n            [xafter,yafter,wafter,hafter]=listofcd[i+1]\n            if w<9 and h<9 and w>3 and h>3:\n                #and w in range(h-2,h+2):\n                a=0\n                for i in range(0,len(listofcd)):\n                    [xcheck,ycheck,wcheck,hcheck]=listofcd[i]\n                    #if [xcheck,ycheck,wcheck,hcheck] != [x,y,w,h] and not ycheck in range(y-100,y+50) and not xcheck in range(x+1,x+150):\n                    if [xcheck,ycheck,wcheck,hcheck] != [x,y,w,h]:\n                        if xcheck in range(x-1,x+10) and ycheck in range(y-5,y+10):\n                            a+=1\n                            #print(str(a))\n                            break\n                if a==0:\n                    countrect+=1\n                    cv2.rectangle(imgc, (x, y), (x+w, y+h), (0, 255, 0), 1)\n                if a>=1:\n                    pass\n    cv2.imshow(\'Contoured\', imgc)\n    cv2.imwrite(dir0+os.path.sep+"after.jpg",imgc)\n    #cv2.waitKey(0)\n    print(str(countrect))\ndef everyletter3(imgdir):\n    src = cv2.imread(imgdir, 0)\n    binary_map = (src > 0).astype(np.uint8)\n    connectivity = 4 # or whatever you prefer\n    output = cv2.connectedComponentsWithStats(binary_map, connectivity, cv2.CV_32S)\n    cv2.imshow(\'Contoured\', output)\n    cv2.waitKey(0)\n    \ndef everyletter5(imgdir):\n    img = cv2.imread(imgdir)\n    (h, w) = img.shape[:2]\n    #height, width, channels = img.shape\n    image_size = h*w\n    mser = cv2.MSER_create()\n    mser.setMaxArea(int(image_size/2))\n    mser.setMinArea(10)\n\n    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) #Converting to GrayScale\n    _, bw = cv2.threshold(gray, 0.0, 255.0, cv2.THRESH_BINARY | cv2.THRESH_OTSU)\n\n    regions, rects = mser.detectRegions(bw)\n\n    # With the rects you can e.g. crop the letters\n    for (x, y, w, h) in rects:\n        cv2.rectangle(img, (x, y), (x+w, y+h), color=(255, 0, 255), thickness=1)\n    cv2.imshow(\'Contoured\', img)\n    cv2.waitKey(0)\ndef everyletter10(imgdir):\n    #method = cv2.cv.CV_TM_SQDIFF_NORMED\n\n    # Read the images from the file\n    small_image = cv2.imread(dir0+os.path.sep+"noteqs.jpg")\n    large_image = cv2.imread(imgdir)\n\n    result = cv2.matchTemplate(small_image, large_image, cv2.TM_SQDIFF_NORMED)\n    print(result)\n\n    # We want the minimum squared difference\n    mn,_,mnLoc,_ = cv2.minMaxLoc(result)\n\n    # Draw the rectangle:\n    # Extract the coordinates of our best match\n    MPx,MPy = mnLoc\n\n    # Step 2: Get the size of the template. This is the same size as the match.\n    trows,tcols = small_image.shape[:2]\n    \n    # Step 3: Draw the rectangle on large_image\n    cv2.rectangle(large_image, (MPx,MPy),(MPx+tcols,MPy+trows),(0,0,255),2)\n\n    # Display the original image with the rectangle around the match.\n    cv2.imshow(\'output\',large_image)\n\n    # The image is only displayed if we call this\n    cv2.waitKey(0)\n\ndef everyletter11(imgdir):\n    #method = cv2.TM_SQDIFF_NORMED\n    # Read the images from the file\n    small_image = cv2.imread(dir0+os.path.sep+"noteqs.jpg")\n    large_image = cv2.imread(imgdir)\n    result=cv2.matchTemplate(small_image, large_image, cv2.TM_SQDIFF_NORMED)\n    ret,result=cv2.threshold(result, 0.7, 1., cv2.THRESH_BINARY);\n    #ret, thresh = cv2.threshold(img, 127, 255, cv.THRESH_BINARY)\n    resb=result.convertTo(resb, cv2.CV_8U, 255);\n    contours=findContours(resb, contours, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE);\n    for i in range(0,len(contours)):\n        #Mat1b mask(result.rows, result.cols, uchar(0));\n        cv2.drawContours(mask, contours, i, (255), cv2.CV_FILLED);\n        #mn,_,mnLoc,_=cv2.minMaxLoc(result, NULL, &max_val, NULL, &max_point, mask);\n        mn,_,mnLoc,_=cv2.minMaxLoc(result);\n        MPx,MPy = mnLoc\n        trows,tcols = small_image.shape[:2]\n        cv2.rectangle(large_image, (MPx,MPy),(MPx+tcols,MPy+trows), (0,255,0), 2);\n    # Display the original image with the rectangle around the match.\n    cv2.imshow(\'output\',large_image)\n\n    # The image is only displayed if we call this\n    cv2.waitKey(0)\ndef everyletter000(imgdir):\n    import cv2\n    import numpy as np\n    from matplotlib import pyplot as plt\n    large_image=imgdir\n    notefsimgdir=dir0+os.path.sep+"notefs.jpg"\n    notecmimgdir=dir0+os.path.sep+"notecm.jpg"\n    noteqsimgdir=dir0+os.path.sep+"noteqs.jpg"\n    img_rgb = cv2.imread(large_image)\n    img_gray = cv2.cvtColor(img_rgb, cv2.COLOR_BGR2GRAY)\n    clist=[]\n    #FS\n    template = cv2.imread(notefsimgdir,0)\n    w, h = template.shape[::-1]\n    res = cv2.matchTemplate(img_gray,template,cv2.TM_CCOEFF_NORMED)\n    threshold = 0.8\n    loc = np.where( res >= threshold)\n    for pt in zip(*loc[::-1]):\n        clist.append([pt[0],pt[1],pt[0] + w, pt[1] + h])\n        #cv2.rectangle(img_rgb, pt, (pt[0] + w, pt[1] + h), (0,0,255), 2)\n    #CM\n    template = cv2.imread(notecmimgdir,0)\n    w, h = template.shape[::-1]\n    res = cv2.matchTemplate(img_gray,template,cv2.TM_CCOEFF_NORMED)\n    threshold = 0.8\n    loc = np.where( res >= threshold)\n    for pt in zip(*loc[::-1]):\n        clist.append([pt[0],pt[1],pt[0] + w, pt[1] + h])\n        #cv2.rectangle(img_rgb, pt, (pt[0] + w, pt[1] + h), (0,0,255), 2)\n    #QS\n    template = cv2.imread(noteqsimgdir,0)\n    w, h = template.shape[::-1]\n    res = cv2.matchTemplate(img_gray,template,cv2.TM_CCOEFF_NORMED)\n    threshold = 0.8\n    loc = np.where( res >= threshold)\n    for pt in zip(*loc[::-1]):\n        clist.append([pt[0],pt[1],pt[0] + w, pt[1] + h])\n        #cv2.rectangle(img_rgb, pt, (pt[0] + w, pt[1] + h), (0,0,255), 2)\n    #print(clist)\n    for c in clist:\n        for i in clist:\n            if c[0] in range(i[0]-5,i[0]+5) and c!=i:\n                clist.remove(i)\n                print(i)\n    for c in clist:           \n        cv2.rectangle(img_rgb, (c[0],c[1]),(c[2],c[3]), (0,0,255), 2)\n\n    #cv2.imwrite(\'res.png\',img_rgb)\n    cv2.imshow(\'output\',img_rgb)\n    cv2.waitKey(0)\n    \n    \nimgdir=dir0+os.path.sep+"20180808185431abcdefghijklm74.jpg"\nprint(imgdir)\neveryletter(imgdir)\n##detect contourarea<50\n##pick that coordinate\n## for f in smallcd: dr\n#cv2.drawContours(img, contours, -1, (0,255,0), 3)\n#if coordinate in range():\n#    x1+scx1,y1+scy1\n#    scx2,x2,scy2,y2\n'